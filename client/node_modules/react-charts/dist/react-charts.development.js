(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactCharts = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var ChartContext = React.createContext();

  var Utils = {
    getStatus: getStatus,
    getStatusStyle: getStatusStyle,
    buildStyleGetters: buildStyleGetters,
    getMultiAnchor: getMultiAnchor,
    getClosestPoint: getClosestPoint,
    normalizeGetter: normalizeGetter,
    isValidPoint: isValidPoint,
    getAxisByAxisID: getAxisByAxisID,
    getAxisIndexByAxisID: getAxisIndexByAxisID,
    sumObjBy: sumObjBy,
    translateX: translateX,
    translateY: translateY,
    translate: translate,
    identity: identity,
    shallowDiff: shallowDiff
  };

  function getStatus(item, focused) {
    var status = {
      focused: false,
      otherFocused: false
    };

    if (!focused) {
      return status;
    } // If the item is a datum


    if (typeof item.primary !== "undefined") {
      var length = focused.group.length;

      for (var i = 0; i < length; i++) {
        if (focused.group[i].seriesID === item.series.id && focused.group[i].index === item.index) {
          status.focused = true;
          break;
        }
      }

      status.otherFocused = !status.focused; // For series
    } else if (focused.series) {
      status.focused = focused.series.id === item.id;
      status.otherFocused = !status.focused;
    }

    return status;
  }

  function getStatusStyle(item, status, decorator, defaults) {
    if (item.series) {
      defaults = _objectSpread2({}, defaults, {}, item.series.style);
    }

    return materializeStyles(decorator(_objectSpread2({}, item, {}, status)), defaults);
  }

  function buildStyleGetters(series, defaults) {
    series.getStatusStyle = function (focused, decorator) {
      var status = getStatus(series, focused);
      series.style = getStatusStyle(series, status, decorator, defaults);
      return series.style;
    }; // We also need to decorate each datum in the same fashion


    series.datums.forEach(function (datum) {
      datum.getStatusStyle = function (focused, decorator) {
        var status = getStatus(datum, focused);
        datum.style = getStatusStyle(datum, status, decorator, defaults);
        return datum.style;
      };
    });
  }

  function getMultiAnchor(_ref) {
    var anchor = _ref.anchor,
        points = _ref.points,
        gridWidth = _ref.gridWidth,
        gridHeight = _ref.gridHeight;

    var invalid = function invalid() {
      throw new Error("".concat(JSON.stringify(anchor), " is not a valid tooltip anchor option. You should use a single anchor option or 2 non-conflicting anchor options."));
    };

    var x;
    var y;
    var xMin = points[0].anchor.x;
    var xMax = points[0].anchor.x;
    var yMin = points[0].anchor.y;
    var yMax = points[0].anchor.y;
    points.forEach(function (point) {
      xMin = Math.min(point.anchor.x, xMin);
      xMax = Math.max(point.anchor.x, xMax);
      yMin = Math.min(point.anchor.y, yMin);
      yMax = Math.max(point.anchor.y, yMax);
    });

    if (anchor.length > 2) {
      return invalid();
    }

    anchor = anchor.sort(function (a) {
      return a.includes("center") || a.includes("Center") ? 1 : -1;
    });

    for (var i = 0; i < anchor.length; i++) {
      var anchorPart = anchor[i]; // Horizontal Positioning

      if (["left", "right", "gridLeft", "gridRight"].includes(anchorPart)) {
        if (typeof x !== "undefined") {
          invalid();
        }

        if (anchorPart === "left") {
          x = xMin;
        } else if (anchorPart === "right") {
          x = xMax;
        } else if (anchorPart === "gridLeft") {
          x = 0;
        } else if (anchorPart === "gridRight") {
          x = gridWidth;
        } else {
          invalid();
        }
      } // Vertical Positioning


      if (["top", "bottom", "gridTop", "gridBottom"].includes(anchorPart)) {
        if (typeof y !== "undefined") {
          invalid();
        }

        if (anchorPart === "top") {
          y = yMin;
        } else if (anchorPart === "bottom") {
          y = yMax;
        } else if (anchorPart === "gridTop") {
          y = 0;
        } else if (anchorPart === "gridBottom") {
          y = gridHeight;
        } else {
          invalid();
        }
      } // Center Positioning


      if (["center", "gridCenter"].includes(anchorPart)) {
        if (anchorPart === "center") {
          if (typeof y === "undefined") {
            y = (yMin + yMax) / 2;
          }

          if (typeof x === "undefined") {
            x = (xMin + xMax) / 2;
          }
        } else if (anchorPart === "gridCenter") {
          if (typeof y === "undefined") {
            y = gridHeight / 2;
          }

          if (typeof x === "undefined") {
            x = gridWidth / 2;
          }
        } else {
          invalid();
        }
      } // Auto center the remainder if there is only one anchorPart listed


      if (anchor.length === 1) {
        if (anchor[0].includes("grid")) {
          anchor.push("gridCenter");
        } else {
          anchor.push("center");
        }
      }
    }

    return {
      x: x,
      y: y
    };
  }

  function getClosestPoint(position, datums) {
    if (!datums || !position || !datums.length) {
      return;
    }

    var closestDistance = Infinity;
    var closestDatum = datums[0];
    datums.forEach(function (datum) {
      datum.boundingPoints.forEach(function (pointerPoint) {
        var distance = Math.sqrt(Math.pow(pointerPoint.x - position.x, 2) + Math.pow(pointerPoint.y - position.y, 2));

        if (distance < closestDistance) {
          closestDistance = distance;
          closestDatum = datum;
        }
      });
    });
    return closestDatum;
  }

  function normalizeColor(style, defaults) {
    return _objectSpread2({}, style, {
      stroke: style.stroke || style.color || defaults.stroke || defaults.color,
      fill: style.fill || style.color || defaults.fill || defaults.color
    });
  }

  var elementTypes = ["area", "line", "rectangle", "circle"];

  function materializeStyles() {
    var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    style = normalizeColor(style, defaults);

    for (var i = 0; i < elementTypes.length; i++) {
      var type = elementTypes[i];
      style[type] = style[type] ? materializeStyles(style[type], defaults) : {};
    }

    return style;
  }

  function normalizeGetter(getter) {
    if (typeof getter === "function") {
      return getter;
    }

    return function (d) {
      return get(d, getter);
    };
  }

  function get(obj, path, def) {
    if (typeof obj === "function") {
      try {
        return obj();
      } catch (e) {
        return path;
      }
    }

    if (!path) {
      return obj;
    }

    var pathObj = makePathArray(path);
    var val;

    try {
      val = pathObj.reduce(function (current, pathPart) {
        return current[pathPart];
      }, obj);
    } catch (e) {// do nothing
    }

    return typeof val !== "undefined" ? val : def;
  }

  function makePathArray(obj) {
    return flattenDeep(obj).join(".").replace("[", ".").replace("]", "").split(".");
  }

  function flattenDeep(arr) {
    var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!Array.isArray(arr)) {
      newArr.push(arr);
    } else {
      for (var i = 0; i < arr.length; i++) {
        flattenDeep(arr[i], newArr);
      }
    }

    return newArr;
  }

  function isValidPoint(d) {
    if (d === null) {
      return false;
    }

    if (typeof d === "undefined") {
      return false;
    }

    if (typeof d === "string" && d === "null") {
      return false;
    }

    return true;
  }

  function getAxisByAxisID(axes, AxisID) {
    return axes.find(function (d) {
      return d.id === AxisID;
    }) || axes[0];
  }

  function getAxisIndexByAxisID(axes, AxisID) {
    var index = axes.findIndex(function (d) {
      return d.id === AxisID;
    });
    return index > -1 ? index : 0;
  }

  function sumObjBy(obj, str) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    }).reduce(function (prev, curr) {
      return prev + curr[str] || 0;
    }, 0);
  }

  function translateX(x) {
    return "translate3d(".concat(Math.round(x), "px, 0, 0)");
  }

  function translateY(y) {
    return "translate3d(0, ".concat(Math.round(y), "px, 0)");
  }

  function translate(x, y) {
    return "translate3d(".concat(Math.round(x), "px, ").concat(Math.round(y), "px, 0)");
  }

  function identity(d) {
    return d;
  }

  function shallowDiff(a, b) {
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) {
      return true;
    }

    return Object.keys(a).some(function (key) {
      if (a[key] !== b[key]) {
        return true;
      }
    });
  }

  var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];

  var rectChanged = function rectChanged(a, b) {
    if (a === void 0) {
      a = {};
    }

    if (b === void 0) {
      b = {};
    }

    return props.some(function (prop) {
      return a[prop] !== b[prop];
    });
  };

  var observedNodes = /*#__PURE__*/new Map();
  var rafId;

  var run = function run() {
    var changedStates = [];
    observedNodes.forEach(function (state, node) {
      var newRect = node.getBoundingClientRect();

      if (rectChanged(newRect, state.rect)) {
        state.rect = newRect;
        changedStates.push(state);
      }
    });
    changedStates.forEach(function (state) {
      state.callbacks.forEach(function (cb) {
        return cb(state.rect);
      });
    });
    rafId = window.requestAnimationFrame(run);
  };

  function observeRect(node, cb) {
    return {
      observe: function observe() {
        var wasEmpty = observedNodes.size === 0;

        if (observedNodes.has(node)) {
          observedNodes.get(node).callbacks.push(cb);
        } else {
          observedNodes.set(node, {
            rect: undefined,
            hasRectChanged: false,
            callbacks: [cb]
          });
        }

        if (wasEmpty) run();
      },
      unobserve: function unobserve() {
        var state = observedNodes.get(node);

        if (state) {
          // Remove the callback
          var index = state.callbacks.indexOf(cb);
          if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference

          if (!state.callbacks.length) observedNodes["delete"](node); // Stop the loop

          if (!observedNodes.size) cancelAnimationFrame(rafId);
        }
      }
    };
  }

  var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

  function useRect(nodeRef) {
    var _nodeRef$current;

    var _React$useState = React.useState((_nodeRef$current = nodeRef.current) === null || _nodeRef$current === void 0 ? void 0 : _nodeRef$current.parentElement),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        element = _React$useState2[0],
        setElement = _React$useState2[1];

    var _React$useState3 = React.useState({
      width: 0,
      height: 0
    }),
        _React$useState4 = _slicedToArray(_React$useState3, 2),
        rect = _React$useState4[0],
        setRect = _React$useState4[1];

    var initialRectSet = React.useRef(false);
    useIsomorphicLayoutEffect(function () {
      var _nodeRef$current2;

      if (((_nodeRef$current2 = nodeRef.current) === null || _nodeRef$current2 === void 0 ? void 0 : _nodeRef$current2.parentElement) !== element) {
        var _nodeRef$current3;

        setElement((_nodeRef$current3 = nodeRef.current) === null || _nodeRef$current3 === void 0 ? void 0 : _nodeRef$current3.parentElement);
      }
    });
    useIsomorphicLayoutEffect(function () {
      if (element && !initialRectSet.current) {
        initialRectSet.current = true;
        setRect(element.getBoundingClientRect());
      }
    }, [element]);
    React.useEffect(function () {
      if (!element) {
        return;
      }

      var observer = observeRect(element, setRect);
      observer.observe();
      return function () {
        observer.unobserve();
      };
    }, [element]);
    return {
      width: rect.width,
      height: rect.height
    };
  }

  function useLatestRef(latest) {
    var ref = React.useRef();
    ref.current = latest;
    return ref;
  }

  function useLatest(obj) {
    var when = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var ref = React.useRef();

    if (when) {
      ref.current = obj;
    }

    return ref.current;
  }

  function usePrevious(val) {
    var ref = React.useRef();
    React.useEffect(function () {
      ref.current = val;
    }, [val]);
    return ref.current;
  }

  var now = require('performance-now'),
      root = typeof window === 'undefined' ? global : window,
      vendors = ['moz', 'webkit'],
      suffix = 'AnimationFrame',
      raf = root['request' + suffix],
      caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

  for (var i = 0; !raf && i < vendors.length; i++) {
    raf = root[vendors[i] + 'Request' + suffix];
    caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
  } // Some versions of FF have rAF but not cAF


  if (!raf || !caf) {
    var last = 0,
        id = 0,
        queue = [],
        frameDuration = 1000 / 60;

    raf = function raf(callback) {
      if (queue.length === 0) {
        var _now = now(),
            next = Math.max(0, frameDuration - (_now - last));

        last = next + _now;
        setTimeout(function () {
          var cp = queue.slice(0); // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue

          queue.length = 0;

          for (var i = 0; i < cp.length; i++) {
            if (!cp[i].cancelled) {
              try {
                cp[i].callback(last);
              } catch (e) {
                setTimeout(function () {
                  throw e;
                }, 0);
              }
            }
          }
        }, Math.round(next));
      }

      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false
      });
      return id;
    };

    caf = function caf(handle) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  function Raf(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn);
  }

  Raf.cancel = function () {
    caf.apply(root, arguments);
  };

  Raf.polyfill = function (object) {
    if (!object) {
      object = root;
    }

    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };

  var defaultStyle = {
    strokeWidth: 0,
    fill: "#333",
    opacity: 1,
    rx: 0,
    ry: 0
  };
  function Rectangle(_ref) {
    var style = _ref.style,
        _ref$opacity = _ref.opacity,
        x1 = _ref.x1,
        y1 = _ref.y1,
        x2 = _ref.x2,
        y2 = _ref.y2,
        rest = _objectWithoutProperties(_ref, ["style", "opacity", "x1", "y1", "x2", "y2"]);

    var resolvedStyle = _objectSpread2({}, defaultStyle, {}, style);

    var xStart = Math.min(x1, x2);
    var yStart = Math.min(y1, y2);
    var xEnd = Math.max(x1, x2);
    var yEnd = Math.max(y1, y2);
    var height = Math.max(yEnd - yStart, 0);
    var width = Math.max(xEnd - xStart, 0);
    return /*#__PURE__*/React.createElement("rect", _extends({}, rest, {
      x: xStart,
      y: yStart,
      width: width,
      height: height,
      style: resolvedStyle
    }));
  }

  function t(t) {
    return function () {
      return t;
    };
  }

  function n(t) {
    return t[0];
  }

  function e(t) {
    return t[1];
  }

  function i$1() {
    this._ = null;
  }

  function r(t) {
    t.U = t.C = t.L = t.R = t.P = t.N = null;
  }

  function o(t, n) {
    var e = n,
        i = n.R,
        r = e.U;
    r ? r.L === e ? r.L = i : r.R = i : t._ = i, i.U = r, e.U = i, e.R = i.L, e.R && (e.R.U = e), i.L = e;
  }

  function s(t, n) {
    var e = n,
        i = n.L,
        r = e.U;
    r ? r.L === e ? r.L = i : r.R = i : t._ = i, i.U = r, e.U = i, e.L = i.R, e.L && (e.L.U = e), i.R = e;
  }

  function u(t) {
    for (; t.L;) {
      t = t.L;
    }

    return t;
  }

  function a(t, n, e, i) {
    var r = [null, null],
        o = A.push(r) - 1;
    return r.left = t, r.right = n, e && c(r, t, n, e), i && c(r, n, t, i), D[t.index].halfedges.push(o), D[n.index].halfedges.push(o), r;
  }

  function h(t, n, e) {
    var i = [n, e];
    return i.left = t, i;
  }

  function c(t, n, e, i) {
    t[0] || t[1] ? t.left === e ? t[1] = i : t[0] = i : (t[0] = i, t.left = n, t.right = e);
  }

  function l(t, n, e, i, r) {
    var o,
        s = t[0],
        u = t[1],
        a = s[0],
        h = s[1],
        c = 0,
        l = 1,
        f = u[0] - a,
        _ = u[1] - h;

    if (o = n - a, f || !(o > 0)) {
      if (o /= f, f < 0) {
        if (o < c) return;
        o < l && (l = o);
      } else if (f > 0) {
        if (o > l) return;
        o > c && (c = o);
      }

      if (o = i - a, f || !(o < 0)) {
        if (o /= f, f < 0) {
          if (o > l) return;
          o > c && (c = o);
        } else if (f > 0) {
          if (o < c) return;
          o < l && (l = o);
        }

        if (o = e - h, _ || !(o > 0)) {
          if (o /= _, _ < 0) {
            if (o < c) return;
            o < l && (l = o);
          } else if (_ > 0) {
            if (o > l) return;
            o > c && (c = o);
          }

          if (o = r - h, _ || !(o < 0)) {
            if (o /= _, _ < 0) {
              if (o > l) return;
              o > c && (c = o);
            } else if (_ > 0) {
              if (o < c) return;
              o < l && (l = o);
            }

            return !(c > 0 || l < 1) || (c > 0 && (t[0] = [a + c * f, h + c * _]), l < 1 && (t[1] = [a + l * f, h + l * _]), !0);
          }
        }
      }
    }
  }

  function f(t, n, e, i, r) {
    var o = t[1];
    if (o) return !0;
    var s,
        u,
        a = t[0],
        h = t.left,
        c = t.right,
        l = h[0],
        f = h[1],
        _ = c[0],
        y = c[1],
        g = (l + _) / 2,
        p = (f + y) / 2;

    if (y === f) {
      if (g < n || g >= i) return;

      if (l > _) {
        if (a) {
          if (a[1] >= r) return;
        } else a = [g, e];

        o = [g, r];
      } else {
        if (a) {
          if (a[1] < e) return;
        } else a = [g, r];

        o = [g, e];
      }
    } else if (u = p - (s = (l - _) / (y - f)) * g, s < -1 || s > 1) {
      if (l > _) {
        if (a) {
          if (a[1] >= r) return;
        } else a = [(e - u) / s, e];

        o = [(r - u) / s, r];
      } else {
        if (a) {
          if (a[1] < e) return;
        } else a = [(r - u) / s, r];

        o = [(e - u) / s, e];
      }
    } else if (f < y) {
      if (a) {
        if (a[0] >= i) return;
      } else a = [n, s * n + u];

      o = [i, s * i + u];
    } else {
      if (a) {
        if (a[0] < n) return;
      } else a = [i, s * i + u];

      o = [n, s * n + u];
    }

    return t[0] = a, t[1] = o, !0;
  }

  function _(t, n) {
    var e = t.site,
        i = n.left,
        r = n.right;
    return e === r && (r = i, i = e), r ? Math.atan2(r[1] - i[1], r[0] - i[0]) : (e === i ? (i = n[1], r = n[0]) : (i = n[0], r = n[1]), Math.atan2(i[0] - r[0], r[1] - i[1]));
  }

  function y(t, n) {
    return n[+(n.left !== t.site)];
  }

  function g(t, n) {
    return n[+(n.left === t.site)];
  }

  i$1.prototype = {
    constructor: i$1,
    insert: function insert(t, n) {
      var e, i, r;

      if (t) {
        if (n.P = t, n.N = t.N, t.N && (t.N.P = n), t.N = n, t.R) {
          for (t = t.R; t.L;) {
            t = t.L;
          }

          t.L = n;
        } else t.R = n;

        e = t;
      } else this._ ? (t = u(this._), n.P = null, n.N = t, t.P = t.L = n, e = t) : (n.P = n.N = null, this._ = n, e = null);

      for (n.L = n.R = null, n.U = e, n.C = !0, t = n; e && e.C;) {
        e === (i = e.U).L ? (r = i.R) && r.C ? (e.C = r.C = !1, i.C = !0, t = i) : (t === e.R && (o(this, e), e = (t = e).U), e.C = !1, i.C = !0, s(this, i)) : (r = i.L) && r.C ? (e.C = r.C = !1, i.C = !0, t = i) : (t === e.L && (s(this, e), e = (t = e).U), e.C = !1, i.C = !0, o(this, i)), e = t.U;
      }

      this._.C = !1;
    },
    remove: function remove(t) {
      t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null;
      var n,
          e,
          i,
          r = t.U,
          a = t.L,
          h = t.R;
      if (e = a ? h ? u(h) : a : h, r ? r.L === t ? r.L = e : r.R = e : this._ = e, a && h ? (i = e.C, e.C = t.C, e.L = a, a.U = e, e !== h ? (r = e.U, e.U = t.U, t = e.R, r.L = t, e.R = h, h.U = e) : (e.U = r, r = e, t = e.R)) : (i = t.C, t = e), t && (t.U = r), !i) if (t && t.C) t.C = !1;else {
        do {
          if (t === this._) break;

          if (t === r.L) {
            if ((n = r.R).C && (n.C = !1, r.C = !0, o(this, r), n = r.R), n.L && n.L.C || n.R && n.R.C) {
              n.R && n.R.C || (n.L.C = !1, n.C = !0, s(this, n), n = r.R), n.C = r.C, r.C = n.R.C = !1, o(this, r), t = this._;
              break;
            }
          } else if ((n = r.L).C && (n.C = !1, r.C = !0, s(this, r), n = r.L), n.L && n.L.C || n.R && n.R.C) {
            n.L && n.L.C || (n.R.C = !1, n.C = !0, o(this, n), n = r.L), n.C = r.C, r.C = n.L.C = !1, s(this, r), t = this._;
            break;
          }

          n.C = !0, t = r, r = r.U;
        } while (!t.C);

        t && (t.C = !1);
      }
    }
  };
  var p,
      x = [];

  function d() {
    r(this), this.x = this.y = this.arc = this.site = this.cy = null;
  }

  function v(t) {
    var n = t.P,
        e = t.N;

    if (n && e) {
      var i = n.site,
          r = t.site,
          o = e.site;

      if (i !== o) {
        var s = r[0],
            u = r[1],
            a = i[0] - s,
            h = i[1] - u,
            c = o[0] - s,
            l = o[1] - u,
            f = 2 * (a * l - h * c);

        if (!(f >= -E)) {
          var _ = a * a + h * h,
              y = c * c + l * l,
              g = (l * _ - h * y) / f,
              v = (a * y - c * _) / f,
              m = x.pop() || new d();

          m.arc = t, m.site = r, m.x = g + s, m.y = (m.cy = v + u) + Math.sqrt(g * g + v * v), t.circle = m;

          for (var M = null, w = L._; w;) {
            if (m.y < w.y || m.y === w.y && m.x <= w.x) {
              if (!w.L) {
                M = w.P;
                break;
              }

              w = w.L;
            } else {
              if (!w.R) {
                M = w;
                break;
              }

              w = w.R;
            }
          }

          L.insert(M, m), M || (p = m);
        }
      }
    }
  }

  function m(t) {
    var n = t.circle;
    n && (n.P || (p = n.N), L.remove(n), x.push(n), r(n), t.circle = null);
  }

  var M = [];

  function w() {
    r(this), this.edge = this.site = this.circle = null;
  }

  function b(t) {
    var n = M.pop() || new w();
    return n.site = t, n;
  }

  function T(t) {
    m(t), S.remove(t), M.push(t), r(t);
  }

  function C(t) {
    var n = t.circle,
        e = n.x,
        i = n.cy,
        r = [e, i],
        o = t.P,
        s = t.N,
        u = [t];
    T(t);

    for (var h = o; h.circle && Math.abs(e - h.circle.x) < R && Math.abs(i - h.circle.cy) < R;) {
      o = h.P, u.unshift(h), T(h), h = o;
    }

    u.unshift(h), m(h);

    for (var l = s; l.circle && Math.abs(e - l.circle.x) < R && Math.abs(i - l.circle.cy) < R;) {
      s = l.N, u.push(l), T(l), l = s;
    }

    u.push(l), m(l);
    var f,
        _ = u.length;

    for (f = 1; f < _; ++f) {
      l = u[f], h = u[f - 1], c(l.edge, h.site, l.site, r);
    }

    h = u[0], (l = u[_ - 1]).edge = a(h.site, l.site, null, r), v(h), v(l);
  }

  function N(t) {
    for (var n, e, i, r, o = t[0], s = t[1], u = S._; u;) {
      if ((i = k(u, s) - o) > R) u = u.L;else {
        if (!((r = o - U(u, s)) > R)) {
          i > -R ? (n = u.P, e = u) : r > -R ? (n = u, e = u.N) : n = e = u;
          break;
        }

        if (!u.R) {
          n = u;
          break;
        }

        u = u.R;
      }
    }

    !function (t) {
      D[t.index] = {
        site: t,
        halfedges: []
      };
    }(t);
    var h = b(t);

    if (S.insert(n, h), n || e) {
      if (n === e) return m(n), e = b(n.site), S.insert(h, e), h.edge = e.edge = a(n.site, h.site), v(n), void v(e);

      if (e) {
        m(n), m(e);
        var l = n.site,
            f = l[0],
            _ = l[1],
            y = t[0] - f,
            g = t[1] - _,
            p = e.site,
            x = p[0] - f,
            d = p[1] - _,
            M = 2 * (y * d - g * x),
            w = y * y + g * g,
            T = x * x + d * d,
            C = [(d * w - g * T) / M + f, (y * T - x * w) / M + _];
        c(e.edge, l, p, C), h.edge = a(l, t, null, C), e.edge = a(t, p, null, C), v(n), v(e);
      } else h.edge = a(n.site, h.site);
    }
  }

  function k(t, n) {
    var e = t.site,
        i = e[0],
        r = e[1],
        o = r - n;
    if (!o) return i;
    var s = t.P;
    if (!s) return -1 / 0;
    var u = (e = s.site)[0],
        a = e[1],
        h = a - n;
    if (!h) return u;
    var c = u - i,
        l = 1 / o - 1 / h,
        f = c / h;
    return l ? (-f + Math.sqrt(f * f - 2 * l * (c * c / (-2 * h) - a + h / 2 + r - o / 2))) / l + i : (i + u) / 2;
  }

  function U(t, n) {
    var e = t.N;
    if (e) return k(e, n);
    var i = t.site;
    return i[1] === n ? i[0] : 1 / 0;
  }

  var S,
      D,
      L,
      A,
      R = 1e-6,
      E = 1e-12;

  function P(t, n) {
    return n[1] - t[1] || n[0] - t[0];
  }

  function F(t, n) {
    var e,
        r,
        o,
        s = t.sort(P).pop();

    for (A = [], D = new Array(t.length), S = new i$1(), L = new i$1();;) {
      if (o = p, s && (!o || s[1] < o.y || s[1] === o.y && s[0] < o.x)) s[0] === e && s[1] === r || (N(s), e = s[0], r = s[1]), s = t.pop();else {
        if (!o) break;
        C(o.arc);
      }
    }

    if (function () {
      for (var t, n, e, i, r = 0, o = D.length; r < o; ++r) {
        if ((t = D[r]) && (i = (n = t.halfedges).length)) {
          var s = new Array(i),
              u = new Array(i);

          for (e = 0; e < i; ++e) {
            s[e] = e, u[e] = _(t, A[n[e]]);
          }

          for (s.sort(function (t, n) {
            return u[n] - u[t];
          }), e = 0; e < i; ++e) {
            u[e] = n[s[e]];
          }

          for (e = 0; e < i; ++e) {
            n[e] = u[e];
          }
        }
      }
    }(), n) {
      var u = +n[0][0],
          a = +n[0][1],
          c = +n[1][0],
          x = +n[1][1];
      !function (t, n, e, i) {
        for (var r, o = A.length; o--;) {
          f(r = A[o], t, n, e, i) && l(r, t, n, e, i) && (Math.abs(r[0][0] - r[1][0]) > R || Math.abs(r[0][1] - r[1][1]) > R) || delete A[o];
        }
      }(u, a, c, x), function (t, n, e, i) {
        var r,
            o,
            s,
            u,
            a,
            c,
            l,
            f,
            _,
            p,
            x,
            d,
            v = D.length,
            m = !0;

        for (r = 0; r < v; ++r) {
          if (o = D[r]) {
            for (s = o.site, u = (a = o.halfedges).length; u--;) {
              A[a[u]] || a.splice(u, 1);
            }

            for (u = 0, c = a.length; u < c;) {
              x = (p = g(o, A[a[u]]))[0], d = p[1], f = (l = y(o, A[a[++u % c]]))[0], _ = l[1], (Math.abs(x - f) > R || Math.abs(d - _) > R) && (a.splice(u, 0, A.push(h(s, p, Math.abs(x - t) < R && i - d > R ? [t, Math.abs(f - t) < R ? _ : i] : Math.abs(d - i) < R && e - x > R ? [Math.abs(_ - i) < R ? f : e, i] : Math.abs(x - e) < R && d - n > R ? [e, Math.abs(f - e) < R ? _ : n] : Math.abs(d - n) < R && x - t > R ? [Math.abs(_ - n) < R ? f : t, n] : null)) - 1), ++c);
            }

            c && (m = !1);
          }
        }

        if (m) {
          var M,
              w,
              b,
              T = 1 / 0;

          for (r = 0, m = null; r < v; ++r) {
            (o = D[r]) && (b = (M = (s = o.site)[0] - t) * M + (w = s[1] - n) * w) < T && (T = b, m = o);
          }

          if (m) {
            var C = [t, n],
                N = [t, i],
                k = [e, i],
                U = [e, n];
            m.halfedges.push(A.push(h(s = m.site, C, N)) - 1, A.push(h(s, N, k)) - 1, A.push(h(s, k, U)) - 1, A.push(h(s, U, C)) - 1);
          }
        }

        for (r = 0; r < v; ++r) {
          (o = D[r]) && (o.halfedges.length || delete D[r]);
        }
      }(u, a, c, x);
    }

    this.edges = A, this.cells = D, S = L = A = D = null;
  }

  function Y() {
    var i = n,
        r = e,
        o = null;

    function s(t) {
      return new F(t.map(function (n, e) {
        var o = [Math.round(i(n, e, t) / R) * R, Math.round(r(n, e, t) / R) * R];
        return o.index = e, o.data = n, o;
      }), o);
    }

    return s.polygons = function (t) {
      return s(t).polygons();
    }, s.links = function (t) {
      return s(t).links();
    }, s.triangles = function (t) {
      return s(t).triangles();
    }, s.x = function (n) {
      return arguments.length ? (i = "function" == typeof n ? n : t(+n), s) : i;
    }, s.y = function (n) {
      return arguments.length ? (r = "function" == typeof n ? n : t(+n), s) : r;
    }, s.extent = function (t) {
      return arguments.length ? (o = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]], s) : o && [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
    }, s.size = function (t) {
      return arguments.length ? (o = null == t ? null : [[0, 0], [+t[0], +t[1]]], s) : o && [o[1][0] - o[0][0], o[1][1] - o[0][1]];
    }, s;
  }

  function H(t, n) {
    return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
  }

  function q(t) {
    var n;
    return 1 === t.length && (n = t, t = function t(_t2, e) {
      return H(n(_t2), e);
    }), {
      left: function left(n, e, i, r) {
        for (null == i && (i = 0), null == r && (r = n.length); i < r;) {
          var o = i + r >>> 1;
          t(n[o], e) < 0 ? i = o + 1 : r = o;
        }

        return i;
      },
      right: function right(n, e, i, r) {
        for (null == i && (i = 0), null == r && (r = n.length); i < r;) {
          var o = i + r >>> 1;
          t(n[o], e) > 0 ? r = o : i = o + 1;
        }

        return i;
      }
    };
  }

  F.prototype = {
    constructor: F,
    polygons: function polygons() {
      var t = this.edges;
      return this.cells.map(function (n) {
        var e = n.halfedges.map(function (e) {
          return y(n, t[e]);
        });
        return e.data = n.site.data, e;
      });
    },
    triangles: function triangles() {
      var t = [],
          n = this.edges;
      return this.cells.forEach(function (e, i) {
        if (o = (r = e.halfedges).length) for (var r, o, s, u, a, h, c = e.site, l = -1, f = n[r[o - 1]], _ = f.left === c ? f.right : f.left; ++l < o;) {
          s = _, _ = (f = n[r[l]]).left === c ? f.right : f.left, s && _ && i < s.index && i < _.index && (a = s, h = _, ((u = c)[0] - h[0]) * (a[1] - u[1]) - (u[0] - a[0]) * (h[1] - u[1]) < 0) && t.push([c.data, s.data, _.data]);
        }
      }), t;
    },
    links: function links() {
      return this.edges.filter(function (t) {
        return t.right;
      }).map(function (t) {
        return {
          source: t.left.data,
          target: t.right.data
        };
      });
    },
    find: function find(t, n, e) {
      for (var i, r, o = this, s = o._found || 0, u = o.cells.length; !(r = o.cells[s]);) {
        if (++s >= u) return null;
      }

      var a = t - r.site[0],
          h = n - r.site[1],
          c = a * a + h * h;

      do {
        r = o.cells[i = s], s = null, r.halfedges.forEach(function (e) {
          var i = o.edges[e],
              u = i.left;

          if (u !== r.site && u || (u = i.right)) {
            var a = t - u[0],
                h = n - u[1],
                l = a * a + h * h;
            l < c && (c = l, s = u.index);
          }
        });
      } while (null !== s);

      return o._found = i, null == e || c <= e * e ? r.site : null;
    }
  };
  var z = q(H).right;

  function j(t, n, e) {
    t = +t, n = +n, e = (r = arguments.length) < 2 ? (n = t, t = 0, 1) : r < 3 ? 1 : +e;

    for (var i = -1, r = 0 | Math.max(0, Math.ceil((n - t) / e)), o = new Array(r); ++i < r;) {
      o[i] = t + i * e;
    }

    return o;
  }

  var O = Math.sqrt(50),
      Z = Math.sqrt(10),
      I = Math.sqrt(2);

  function $(t, n, e) {
    var i,
        r,
        o,
        s,
        u = -1;
    if (e = +e, (t = +t) === (n = +n) && e > 0) return [t];
    if ((i = n < t) && (r = t, t = n, n = r), 0 === (s = V(t, n, e)) || !isFinite(s)) return [];
    if (s > 0) for (t = Math.ceil(t / s), n = Math.floor(n / s), o = new Array(r = Math.ceil(n - t + 1)); ++u < r;) {
      o[u] = (t + u) * s;
    } else for (t = Math.floor(t * s), n = Math.ceil(n * s), o = new Array(r = Math.ceil(t - n + 1)); ++u < r;) {
      o[u] = (t - u) / s;
    }
    return i && o.reverse(), o;
  }

  function V(t, n, e) {
    var i = (n - t) / Math.max(0, e),
        r = Math.floor(Math.log(i) / Math.LN10),
        o = i / Math.pow(10, r);
    return r >= 0 ? (o >= O ? 10 : o >= Z ? 5 : o >= I ? 2 : 1) * Math.pow(10, r) : -Math.pow(10, -r) / (o >= O ? 10 : o >= Z ? 5 : o >= I ? 2 : 1);
  }

  function B(t, n, e) {
    var i = Math.abs(n - t) / Math.max(0, e),
        r = Math.pow(10, Math.floor(Math.log(i) / Math.LN10)),
        o = i / r;
    return o >= O ? r *= 10 : o >= Z ? r *= 5 : o >= I && (r *= 2), n < t ? -r : r;
  }

  function X(t, n) {
    switch (arguments.length) {
      case 0:
        break;

      case 1:
        this.range(t);
        break;

      default:
        this.range(n).domain(t);
    }

    return this;
  }

  var W = Symbol("implicit");

  function Q() {
    var t = new Map(),
        n = [],
        e = [],
        i = W;

    function r(r) {
      var o = r + "",
          s = t.get(o);

      if (!s) {
        if (i !== W) return i;
        t.set(o, s = n.push(r));
      }

      return e[(s - 1) % e.length];
    }

    return r.domain = function (e) {
      if (!arguments.length) return n.slice();
      n = [], t = new Map();

      var _iterator = _createForOfIteratorHelper(e),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _i2 = _step.value;

          var _e2 = _i2 + "";

          t.has(_e2) || t.set(_e2, n.push(_i2));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return r;
    }, r.range = function (t) {
      return arguments.length ? (e = Array.from(t), r) : e.slice();
    }, r.unknown = function (t) {
      return arguments.length ? (i = t, r) : i;
    }, r.copy = function () {
      return Q(n, e).unknown(i);
    }, X.apply(r, arguments), r;
  }

  function J() {
    var t,
        n,
        e = Q().unknown(void 0),
        i = e.domain,
        r = e.range,
        o = 0,
        s = 1,
        u = !1,
        a = 0,
        h = 0,
        c = .5;

    function l() {
      var e = i().length,
          l = s < o,
          f = l ? s : o,
          _ = l ? o : s;

      t = (_ - f) / Math.max(1, e - a + 2 * h), u && (t = Math.floor(t)), f += (_ - f - t * (e - a)) * c, n = t * (1 - a), u && (f = Math.round(f), n = Math.round(n));
      var y = j(e).map(function (n) {
        return f + t * n;
      });
      return r(l ? y.reverse() : y);
    }

    return delete e.unknown, e.domain = function (t) {
      return arguments.length ? (i(t), l()) : i();
    }, e.range = function (t) {
      var _t3, _t4;

      return arguments.length ? ((_t3 = t, _t4 = _slicedToArray(_t3, 2), o = _t4[0], s = _t4[1], _t3), o = +o, s = +s, l()) : [o, s];
    }, e.rangeRound = function (t) {
      var _t5, _t6;

      return (_t5 = t, _t6 = _slicedToArray(_t5, 2), o = _t6[0], s = _t6[1], _t5), o = +o, s = +s, u = !0, l();
    }, e.bandwidth = function () {
      return n;
    }, e.step = function () {
      return t;
    }, e.round = function (t) {
      return arguments.length ? (u = !!t, l()) : u;
    }, e.padding = function (t) {
      return arguments.length ? (a = Math.min(1, h = +t), l()) : a;
    }, e.paddingInner = function (t) {
      return arguments.length ? (a = Math.min(1, t), l()) : a;
    }, e.paddingOuter = function (t) {
      return arguments.length ? (h = +t, l()) : h;
    }, e.align = function (t) {
      return arguments.length ? (c = Math.max(0, Math.min(1, t)), l()) : c;
    }, e.copy = function () {
      return J(i(), [o, s]).round(u).paddingInner(a).paddingOuter(h).align(c);
    }, X.apply(l(), arguments);
  }

  function G(t, n, e) {
    t.prototype = n.prototype = e, e.constructor = t;
  }

  function K(t, n) {
    var e = Object.create(t.prototype);

    for (var i in n) {
      e[i] = n[i];
    }

    return e;
  }

  function tt() {}

  var nt = "\\s*([+-]?\\d+)\\s*",
      et = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      it = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      rt = /^#([0-9a-f]{3,8})$/,
      ot = new RegExp("^rgb\\(" + [nt, nt, nt] + "\\)$"),
      st = new RegExp("^rgb\\(" + [it, it, it] + "\\)$"),
      ut = new RegExp("^rgba\\(" + [nt, nt, nt, et] + "\\)$"),
      at = new RegExp("^rgba\\(" + [it, it, it, et] + "\\)$"),
      ht = new RegExp("^hsl\\(" + [et, it, it] + "\\)$"),
      ct = new RegExp("^hsla\\(" + [et, it, it, et] + "\\)$"),
      lt = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };

  function ft() {
    return this.rgb().formatHex();
  }

  function _t() {
    return this.rgb().formatRgb();
  }

  function yt(t) {
    var n, e;
    return t = (t + "").trim().toLowerCase(), (n = rt.exec(t)) ? (e = n[1].length, n = parseInt(n[1], 16), 6 === e ? gt(n) : 3 === e ? new vt(n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, (15 & n) << 4 | 15 & n, 1) : 8 === e ? new vt(n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, (255 & n) / 255) : 4 === e ? new vt(n >> 12 & 15 | n >> 8 & 240, n >> 8 & 15 | n >> 4 & 240, n >> 4 & 15 | 240 & n, ((15 & n) << 4 | 15 & n) / 255) : null) : (n = ot.exec(t)) ? new vt(n[1], n[2], n[3], 1) : (n = st.exec(t)) ? new vt(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, 1) : (n = ut.exec(t)) ? pt(n[1], n[2], n[3], n[4]) : (n = at.exec(t)) ? pt(255 * n[1] / 100, 255 * n[2] / 100, 255 * n[3] / 100, n[4]) : (n = ht.exec(t)) ? bt(n[1], n[2] / 100, n[3] / 100, 1) : (n = ct.exec(t)) ? bt(n[1], n[2] / 100, n[3] / 100, n[4]) : lt.hasOwnProperty(t) ? gt(lt[t]) : "transparent" === t ? new vt(NaN, NaN, NaN, 0) : null;
  }

  function gt(t) {
    return new vt(t >> 16 & 255, t >> 8 & 255, 255 & t, 1);
  }

  function pt(t, n, e, i) {
    return i <= 0 && (t = n = e = NaN), new vt(t, n, e, i);
  }

  function xt(t) {
    return t instanceof tt || (t = yt(t)), t ? new vt((t = t.rgb()).r, t.g, t.b, t.opacity) : new vt();
  }

  function dt(t, n, e, i) {
    return 1 === arguments.length ? xt(t) : new vt(t, n, e, null == i ? 1 : i);
  }

  function vt(t, n, e, i) {
    this.r = +t, this.g = +n, this.b = +e, this.opacity = +i;
  }

  function mt() {
    return "#" + wt(this.r) + wt(this.g) + wt(this.b);
  }

  function Mt() {
    var t = this.opacity;
    return (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (1 === t ? ")" : ", " + t + ")");
  }

  function wt(t) {
    return ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? "0" : "") + t.toString(16);
  }

  function bt(t, n, e, i) {
    return i <= 0 ? t = n = e = NaN : e <= 0 || e >= 1 ? t = n = NaN : n <= 0 && (t = NaN), new Ct(t, n, e, i);
  }

  function Tt(t) {
    if (t instanceof Ct) return new Ct(t.h, t.s, t.l, t.opacity);
    if (t instanceof tt || (t = yt(t)), !t) return new Ct();
    if (t instanceof Ct) return t;
    var n = (t = t.rgb()).r / 255,
        e = t.g / 255,
        i = t.b / 255,
        r = Math.min(n, e, i),
        o = Math.max(n, e, i),
        s = NaN,
        u = o - r,
        a = (o + r) / 2;
    return u ? (s = n === o ? (e - i) / u + 6 * (e < i) : e === o ? (i - n) / u + 2 : (n - e) / u + 4, u /= a < .5 ? o + r : 2 - o - r, s *= 60) : u = a > 0 && a < 1 ? 0 : s, new Ct(s, u, a, t.opacity);
  }

  function Ct(t, n, e, i) {
    this.h = +t, this.s = +n, this.l = +e, this.opacity = +i;
  }

  function Nt(t, n, e) {
    return 255 * (t < 60 ? n + (e - n) * t / 60 : t < 180 ? e : t < 240 ? n + (e - n) * (240 - t) / 60 : n);
  }

  function kt(t) {
    return function () {
      return t;
    };
  }

  function Ut(t) {
    return 1 == (t = +t) ? St : function (n, e) {
      return e - n ? function (t, n, e) {
        return t = Math.pow(t, e), n = Math.pow(n, e) - t, e = 1 / e, function (i) {
          return Math.pow(t + i * n, e);
        };
      }(n, e, t) : kt(isNaN(n) ? e : n);
    };
  }

  function St(t, n) {
    var e = n - t;
    return e ? function (t, n) {
      return function (e) {
        return t + e * n;
      };
    }(t, e) : kt(isNaN(t) ? n : t);
  }

  G(tt, yt, {
    copy: function copy(t) {
      return Object.assign(new this.constructor(), this, t);
    },
    displayable: function displayable() {
      return this.rgb().displayable();
    },
    hex: ft,
    formatHex: ft,
    formatHsl: function formatHsl() {
      return Tt(this).formatHsl();
    },
    formatRgb: _t,
    toString: _t
  }), G(vt, dt, K(tt, {
    brighter: function brighter(t) {
      return t = null == t ? 1 / .7 : Math.pow(1 / .7, t), new vt(this.r * t, this.g * t, this.b * t, this.opacity);
    },
    darker: function darker(t) {
      return t = null == t ? .7 : Math.pow(.7, t), new vt(this.r * t, this.g * t, this.b * t, this.opacity);
    },
    rgb: function rgb() {
      return this;
    },
    displayable: function displayable() {
      return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: mt,
    formatHex: mt,
    formatRgb: Mt,
    toString: Mt
  })), G(Ct, function (t, n, e, i) {
    return 1 === arguments.length ? Tt(t) : new Ct(t, n, e, null == i ? 1 : i);
  }, K(tt, {
    brighter: function brighter(t) {
      return t = null == t ? 1 / .7 : Math.pow(1 / .7, t), new Ct(this.h, this.s, this.l * t, this.opacity);
    },
    darker: function darker(t) {
      return t = null == t ? .7 : Math.pow(.7, t), new Ct(this.h, this.s, this.l * t, this.opacity);
    },
    rgb: function rgb() {
      var t = this.h % 360 + 360 * (this.h < 0),
          n = isNaN(t) || isNaN(this.s) ? 0 : this.s,
          e = this.l,
          i = e + (e < .5 ? e : 1 - e) * n,
          r = 2 * e - i;
      return new vt(Nt(t >= 240 ? t - 240 : t + 120, r, i), Nt(t, r, i), Nt(t < 120 ? t + 240 : t - 120, r, i), this.opacity);
    },
    displayable: function displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl: function formatHsl() {
      var t = this.opacity;
      return (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? "hsl(" : "hsla(") + (this.h || 0) + ", " + 100 * (this.s || 0) + "%, " + 100 * (this.l || 0) + "%" + (1 === t ? ")" : ", " + t + ")");
    }
  }));

  var Dt = function t(n) {
    var e = Ut(n);

    function i(t, n) {
      var i = e((t = dt(t)).r, (n = dt(n)).r),
          r = e(t.g, n.g),
          o = e(t.b, n.b),
          s = St(t.opacity, n.opacity);
      return function (n) {
        return t.r = i(n), t.g = r(n), t.b = o(n), t.opacity = s(n), t + "";
      };
    }

    return i.gamma = t, i;
  }(1);

  function Lt(t, n) {
    n || (n = []);
    var e,
        i = t ? Math.min(n.length, t.length) : 0,
        r = n.slice();
    return function (o) {
      for (e = 0; e < i; ++e) {
        r[e] = t[e] * (1 - o) + n[e] * o;
      }

      return r;
    };
  }

  function At(t, n) {
    var e,
        i = n ? n.length : 0,
        r = t ? Math.min(i, t.length) : 0,
        o = new Array(r),
        s = new Array(i);

    for (e = 0; e < r; ++e) {
      o[e] = qt(t[e], n[e]);
    }

    for (; e < i; ++e) {
      s[e] = n[e];
    }

    return function (t) {
      for (e = 0; e < r; ++e) {
        s[e] = o[e](t);
      }

      return s;
    };
  }

  function Rt(t, n) {
    var e = new Date();
    return t = +t, n = +n, function (i) {
      return e.setTime(t * (1 - i) + n * i), e;
    };
  }

  function Et(t, n) {
    return t = +t, n = +n, function (e) {
      return t * (1 - e) + n * e;
    };
  }

  function Pt(t, n) {
    var e,
        i = {},
        r = {};

    for (e in null !== t && "object" == _typeof(t) || (t = {}), null !== n && "object" == _typeof(n) || (n = {}), n) {
      e in t ? i[e] = qt(t[e], n[e]) : r[e] = n[e];
    }

    return function (t) {
      for (e in i) {
        r[e] = i[e](t);
      }

      return r;
    };
  }

  var Ft = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      Yt = new RegExp(Ft.source, "g");

  function Ht(t, n) {
    var e,
        i,
        r,
        o = Ft.lastIndex = Yt.lastIndex = 0,
        s = -1,
        u = [],
        a = [];

    for (t += "", n += ""; (e = Ft.exec(t)) && (i = Yt.exec(n));) {
      (r = i.index) > o && (r = n.slice(o, r), u[s] ? u[s] += r : u[++s] = r), (e = e[0]) === (i = i[0]) ? u[s] ? u[s] += i : u[++s] = i : (u[++s] = null, a.push({
        i: s,
        x: Et(e, i)
      })), o = Yt.lastIndex;
    }

    return o < n.length && (r = n.slice(o), u[s] ? u[s] += r : u[++s] = r), u.length < 2 ? a[0] ? function (t) {
      return function (n) {
        return t(n) + "";
      };
    }(a[0].x) : function (t) {
      return function () {
        return t;
      };
    }(n) : (n = a.length, function (t) {
      for (var e, i = 0; i < n; ++i) {
        u[(e = a[i]).i] = e.x(t);
      }

      return u.join("");
    });
  }

  function qt(t, n) {
    var e,
        i = _typeof(n);

    return null == n || "boolean" === i ? kt(n) : ("number" === i ? Et : "string" === i ? (e = yt(n)) ? (n = e, Dt) : Ht : n instanceof yt ? Dt : n instanceof Date ? Rt : function (t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    }(n) ? Lt : Array.isArray(n) ? At : "function" != typeof n.valueOf && "function" != typeof n.toString || isNaN(n) ? Pt : Et)(t, n);
  }

  function zt(t, n) {
    return t = +t, n = +n, function (e) {
      return Math.round(t * (1 - e) + n * e);
    };
  }

  function jt(t) {
    return +t;
  }

  var Ot = [0, 1];

  function Zt(t) {
    return t;
  }

  function It(t, n) {
    return (n -= t = +t) ? function (e) {
      return (e - t) / n;
    } : function (t) {
      return function () {
        return t;
      };
    }(isNaN(n) ? NaN : .5);
  }

  function $t(t, n, e) {
    var i = t[0],
        r = t[1],
        o = n[0],
        s = n[1];
    return r < i ? (i = It(r, i), o = e(s, o)) : (i = It(i, r), o = e(o, s)), function (t) {
      return o(i(t));
    };
  }

  function Vt(t, n, e) {
    var i = Math.min(t.length, n.length) - 1,
        r = new Array(i),
        o = new Array(i),
        s = -1;

    for (t[i] < t[0] && (t = t.slice().reverse(), n = n.slice().reverse()); ++s < i;) {
      r[s] = It(t[s], t[s + 1]), o[s] = e(n[s], n[s + 1]);
    }

    return function (n) {
      var e = z(t, n, 1, i) - 1;
      return o[e](r[e](n));
    };
  }

  function Bt(t, n) {
    return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
  }

  function Xt() {
    var t,
        n,
        e,
        i,
        r,
        o,
        s = Ot,
        u = Ot,
        a = qt,
        h = Zt;

    function c() {
      var t,
          n,
          e,
          a = Math.min(s.length, u.length);
      return h !== Zt && (t = s[0], n = s[a - 1], t > n && (e = t, t = n, n = e), h = function h(e) {
        return Math.max(t, Math.min(n, e));
      }), i = a > 2 ? Vt : $t, r = o = null, l;
    }

    function l(n) {
      return isNaN(n = +n) ? e : (r || (r = i(s.map(t), u, a)))(t(h(n)));
    }

    return l.invert = function (e) {
      return h(n((o || (o = i(u, s.map(t), Et)))(e)));
    }, l.domain = function (t) {
      return arguments.length ? (s = Array.from(t, jt), c()) : s.slice();
    }, l.range = function (t) {
      return arguments.length ? (u = Array.from(t), c()) : u.slice();
    }, l.rangeRound = function (t) {
      return u = Array.from(t), a = zt, c();
    }, l.clamp = function (t) {
      return arguments.length ? (h = !!t || Zt, c()) : h !== Zt;
    }, l.interpolate = function (t) {
      return arguments.length ? (a = t, c()) : a;
    }, l.unknown = function (t) {
      return arguments.length ? (e = t, l) : e;
    }, function (e, i) {
      return t = e, n = i, c();
    };
  }

  function Wt() {
    return Xt()(Zt, Zt);
  }

  function Qt(t, n) {
    if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf("e")) < 0) return null;
    var e,
        i = t.slice(0, e);
    return [i.length > 1 ? i[0] + i.slice(2) : i, +t.slice(e + 1)];
  }

  function Jt(t) {
    return (t = Qt(Math.abs(t))) ? t[1] : NaN;
  }

  var Gt,
      Kt = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function tn(t) {
    if (!(n = Kt.exec(t))) throw new Error("invalid format: " + t);
    var n;
    return new nn({
      fill: n[1],
      align: n[2],
      sign: n[3],
      symbol: n[4],
      zero: n[5],
      width: n[6],
      comma: n[7],
      precision: n[8] && n[8].slice(1),
      trim: n[9],
      type: n[10]
    });
  }

  function nn(t) {
    this.fill = void 0 === t.fill ? " " : t.fill + "", this.align = void 0 === t.align ? ">" : t.align + "", this.sign = void 0 === t.sign ? "-" : t.sign + "", this.symbol = void 0 === t.symbol ? "" : t.symbol + "", this.zero = !!t.zero, this.width = void 0 === t.width ? void 0 : +t.width, this.comma = !!t.comma, this.precision = void 0 === t.precision ? void 0 : +t.precision, this.trim = !!t.trim, this.type = void 0 === t.type ? "" : t.type + "";
  }

  function en(t, n) {
    var e = Qt(t, n);
    if (!e) return t + "";
    var i = e[0],
        r = e[1];
    return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
  }

  tn.prototype = nn.prototype, nn.prototype.toString = function () {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
  };
  var rn = {
    "%": function _(t, n) {
      return (100 * t).toFixed(n);
    },
    b: function b(t) {
      return Math.round(t).toString(2);
    },
    c: function c(t) {
      return t + "";
    },
    d: function d(t) {
      return Math.round(t).toString(10);
    },
    e: function e(t, n) {
      return t.toExponential(n);
    },
    f: function f(t, n) {
      return t.toFixed(n);
    },
    g: function g(t, n) {
      return t.toPrecision(n);
    },
    o: function o(t) {
      return Math.round(t).toString(8);
    },
    p: function p(t, n) {
      return en(100 * t, n);
    },
    r: en,
    s: function s(t, n) {
      var e = Qt(t, n);
      if (!e) return t + "";
      var i = e[0],
          r = e[1],
          o = r - (Gt = 3 * Math.max(-8, Math.min(8, Math.floor(r / 3)))) + 1,
          s = i.length;
      return o === s ? i : o > s ? i + new Array(o - s + 1).join("0") : o > 0 ? i.slice(0, o) + "." + i.slice(o) : "0." + new Array(1 - o).join("0") + Qt(t, Math.max(0, n + o - 1))[0];
    },
    X: function X(t) {
      return Math.round(t).toString(16).toUpperCase();
    },
    x: function x(t) {
      return Math.round(t).toString(16);
    }
  };

  function on(t) {
    return t;
  }

  var sn,
      un,
      an,
      hn = Array.prototype.map,
      cn = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

  function ln(t) {
    var n,
        e,
        i = void 0 === t.grouping || void 0 === t.thousands ? on : (n = hn.call(t.grouping, Number), e = t.thousands + "", function (t, i) {
      for (var r = t.length, o = [], s = 0, u = n[0], a = 0; r > 0 && u > 0 && (a + u + 1 > i && (u = Math.max(1, i - a)), o.push(t.substring(r -= u, r + u)), !((a += u + 1) > i));) {
        u = n[s = (s + 1) % n.length];
      }

      return o.reverse().join(e);
    }),
        r = void 0 === t.currency ? "" : t.currency[0] + "",
        o = void 0 === t.currency ? "" : t.currency[1] + "",
        s = void 0 === t.decimal ? "." : t.decimal + "",
        u = void 0 === t.numerals ? on : function (t) {
      return function (n) {
        return n.replace(/[0-9]/g, function (n) {
          return t[+n];
        });
      };
    }(hn.call(t.numerals, String)),
        a = void 0 === t.percent ? "%" : t.percent + "",
        h = void 0 === t.minus ? "-" : t.minus + "",
        c = void 0 === t.nan ? "NaN" : t.nan + "";

    function l(t) {
      var n = (t = tn(t)).fill,
          e = t.align,
          l = t.sign,
          f = t.symbol,
          _ = t.zero,
          y = t.width,
          g = t.comma,
          p = t.precision,
          x = t.trim,
          d = t.type;
      "n" === d ? (g = !0, d = "g") : rn[d] || (void 0 === p && (p = 12), x = !0, d = "g"), (_ || "0" === n && "=" === e) && (_ = !0, n = "0", e = "=");
      var v = "$" === f ? r : "#" === f && /[boxX]/.test(d) ? "0" + d.toLowerCase() : "",
          m = "$" === f ? o : /[%p]/.test(d) ? a : "",
          M = rn[d],
          w = /[defgprs%]/.test(d);

      function b(t) {
        var r,
            o,
            a,
            f = v,
            b = m;
        if ("c" === d) b = M(t) + b, t = "";else {
          var T = (t = +t) < 0;
          if (t = isNaN(t) ? c : M(Math.abs(t), p), x && (t = function (t) {
            t: for (var n, e = t.length, i = 1, r = -1; i < e; ++i) {
              switch (t[i]) {
                case ".":
                  r = n = i;
                  break;

                case "0":
                  0 === r && (r = i), n = i;
                  break;

                default:
                  if (r > 0) {
                    if (!+t[i]) break t;
                    r = 0;
                  }

              }
            }

            return r > 0 ? t.slice(0, r) + t.slice(n + 1) : t;
          }(t)), T && 0 == +t && (T = !1), f = (T ? "(" === l ? l : h : "-" === l || "(" === l ? "" : l) + f, b = ("s" === d ? cn[8 + Gt / 3] : "") + b + (T && "(" === l ? ")" : ""), w) for (r = -1, o = t.length; ++r < o;) {
            if (48 > (a = t.charCodeAt(r)) || a > 57) {
              b = (46 === a ? s + t.slice(r + 1) : t.slice(r)) + b, t = t.slice(0, r);
              break;
            }
          }
        }
        g && !_ && (t = i(t, 1 / 0));
        var C = f.length + t.length + b.length,
            N = C < y ? new Array(y - C + 1).join(n) : "";

        switch (g && _ && (t = i(N + t, N.length ? y - b.length : 1 / 0), N = ""), e) {
          case "<":
            t = f + t + b + N;
            break;

          case "=":
            t = f + N + t + b;
            break;

          case "^":
            t = N.slice(0, C = N.length >> 1) + f + t + b + N.slice(C);
            break;

          default:
            t = N + f + t + b;
        }

        return u(t);
      }

      return p = void 0 === p ? 6 : /[gprs]/.test(d) ? Math.max(1, Math.min(21, p)) : Math.max(0, Math.min(20, p)), b.toString = function () {
        return t + "";
      }, b;
    }

    return {
      format: l,
      formatPrefix: function formatPrefix(t, n) {
        var e = l(((t = tn(t)).type = "f", t)),
            i = 3 * Math.max(-8, Math.min(8, Math.floor(Jt(n) / 3))),
            r = Math.pow(10, -i),
            o = cn[8 + i / 3];
        return function (t) {
          return e(r * t) + o;
        };
      }
    };
  }

  function fn(t, n, e, i) {
    var r,
        o = B(t, n, e);

    switch ((i = tn(null == i ? ",f" : i)).type) {
      case "s":
        var s = Math.max(Math.abs(t), Math.abs(n));
        return null != i.precision || isNaN(r = function (t, n) {
          return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(Jt(n) / 3))) - Jt(Math.abs(t)));
        }(o, s)) || (i.precision = r), an(i, s);

      case "":
      case "e":
      case "g":
      case "p":
      case "r":
        null != i.precision || isNaN(r = function (t, n) {
          return t = Math.abs(t), n = Math.abs(n) - t, Math.max(0, Jt(n) - Jt(t)) + 1;
        }(o, Math.max(Math.abs(t), Math.abs(n)))) || (i.precision = r - ("e" === i.type));
        break;

      case "f":
      case "%":
        null != i.precision || isNaN(r = function (t) {
          return Math.max(0, -Jt(Math.abs(t)));
        }(o)) || (i.precision = r - 2 * ("%" === i.type));
    }

    return un(i);
  }

  function _n(t) {
    var n = t.domain;
    return t.ticks = function (t) {
      var e = n();
      return $(e[0], e[e.length - 1], null == t ? 10 : t);
    }, t.tickFormat = function (t, e) {
      var i = n();
      return fn(i[0], i[i.length - 1], null == t ? 10 : t, e);
    }, t.nice = function (e) {
      null == e && (e = 10);
      var i,
          r = n(),
          o = 0,
          s = r.length - 1,
          u = r[o],
          a = r[s];
      return a < u && (i = u, u = a, a = i, i = o, o = s, s = i), (i = V(u, a, e)) > 0 ? i = V(u = Math.floor(u / i) * i, a = Math.ceil(a / i) * i, e) : i < 0 && (i = V(u = Math.ceil(u * i) / i, a = Math.floor(a * i) / i, e)), i > 0 ? (r[o] = Math.floor(u / i) * i, r[s] = Math.ceil(a / i) * i, n(r)) : i < 0 && (r[o] = Math.ceil(u * i) / i, r[s] = Math.floor(a * i) / i, n(r)), t;
    }, t;
  }

  function yn() {
    var t = Wt();
    return t.copy = function () {
      return Bt(t, yn());
    }, X.apply(t, arguments), _n(t);
  }

  function gn(t, n) {
    var e,
        i = 0,
        r = (t = t.slice()).length - 1,
        o = t[i],
        s = t[r];
    return s < o && (e = i, i = r, r = e, e = o, o = s, s = e), t[i] = n.floor(o), t[r] = n.ceil(s), t;
  }

  function pn(t) {
    return Math.log(t);
  }

  function xn(t) {
    return Math.exp(t);
  }

  function dn(t) {
    return -Math.log(-t);
  }

  function vn(t) {
    return -Math.exp(-t);
  }

  function mn(t) {
    return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t;
  }

  function Mn(t) {
    return function (n) {
      return -t(-n);
    };
  }

  function wn(t) {
    var n,
        e,
        i = t(pn, xn),
        r = i.domain,
        o = 10;

    function s() {
      return n = function (t) {
        return t === Math.E ? Math.log : 10 === t && Math.log10 || 2 === t && Math.log2 || (t = Math.log(t), function (n) {
          return Math.log(n) / t;
        });
      }(o), e = function (t) {
        return 10 === t ? mn : t === Math.E ? Math.exp : function (n) {
          return Math.pow(t, n);
        };
      }(o), r()[0] < 0 ? (n = Mn(n), e = Mn(e), t(dn, vn)) : t(pn, xn), i;
    }

    return i.base = function (t) {
      return arguments.length ? (o = +t, s()) : o;
    }, i.domain = function (t) {
      return arguments.length ? (r(t), s()) : r();
    }, i.ticks = function (t) {
      var i,
          s = r(),
          u = s[0],
          a = s[s.length - 1];
      (i = a < u) && (f = u, u = a, a = f);

      var h,
          c,
          l,
          f = n(u),
          _ = n(a),
          y = null == t ? 10 : +t,
          g = [];

      if (!(o % 1) && _ - f < y) {
        if (f = Math.floor(f), _ = Math.ceil(_), u > 0) {
          for (; f <= _; ++f) {
            for (c = 1, h = e(f); c < o; ++c) {
              if (!((l = h * c) < u)) {
                if (l > a) break;
                g.push(l);
              }
            }
          }
        } else for (; f <= _; ++f) {
          for (c = o - 1, h = e(f); c >= 1; --c) {
            if (!((l = h * c) < u)) {
              if (l > a) break;
              g.push(l);
            }
          }
        }

        2 * g.length < y && (g = $(u, a, y));
      } else g = $(f, _, Math.min(_ - f, y)).map(e);

      return i ? g.reverse() : g;
    }, i.tickFormat = function (t, r) {
      if (null == r && (r = 10 === o ? ".0e" : ","), "function" != typeof r && (r = un(r)), t === 1 / 0) return r;
      null == t && (t = 10);
      var s = Math.max(1, o * t / i.ticks().length);
      return function (t) {
        var i = t / e(Math.round(n(t)));
        return i * o < o - .5 && (i *= o), i <= s ? r(t) : "";
      };
    }, i.nice = function () {
      return r(gn(r(), {
        floor: function floor(t) {
          return e(Math.floor(n(t)));
        },
        ceil: function ceil(t) {
          return e(Math.ceil(n(t)));
        }
      }));
    }, i;
  }

  function bn() {
    var t = wn(Xt()).domain([1, 10]);
    return t.copy = function () {
      return Bt(t, bn()).base(t.base());
    }, X.apply(t, arguments), t;
  }

  sn = ln({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""],
    minus: "-"
  }), un = sn.format, an = sn.formatPrefix;
  var Tn = new Date(),
      Cn = new Date();

  function Nn(t, n, e, i) {
    function r(n) {
      return t(n = 0 === arguments.length ? new Date() : new Date(+n)), n;
    }

    return r.floor = function (n) {
      return t(n = new Date(+n)), n;
    }, r.ceil = function (e) {
      return t(e = new Date(e - 1)), n(e, 1), t(e), e;
    }, r.round = function (t) {
      var n = r(t),
          e = r.ceil(t);
      return t - n < e - t ? n : e;
    }, r.offset = function (t, e) {
      return n(t = new Date(+t), null == e ? 1 : Math.floor(e)), t;
    }, r.range = function (e, i, o) {
      var s,
          u = [];
      if (e = r.ceil(e), o = null == o ? 1 : Math.floor(o), !(e < i && o > 0)) return u;

      do {
        u.push(s = new Date(+e)), n(e, o), t(e);
      } while (s < e && e < i);

      return u;
    }, r.filter = function (e) {
      return Nn(function (n) {
        if (n >= n) for (; t(n), !e(n);) {
          n.setTime(n - 1);
        }
      }, function (t, i) {
        if (t >= t) if (i < 0) for (; ++i <= 0;) {
          for (; n(t, -1), !e(t);) {
          }
        } else for (; --i >= 0;) {
          for (; n(t, 1), !e(t);) {
          }
        }
      });
    }, e && (r.count = function (n, i) {
      return Tn.setTime(+n), Cn.setTime(+i), t(Tn), t(Cn), Math.floor(e(Tn, Cn));
    }, r.every = function (t) {
      return t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? r.filter(i ? function (n) {
        return i(n) % t == 0;
      } : function (n) {
        return r.count(0, n) % t == 0;
      }) : r : null;
    }), r;
  }

  var kn = Nn(function () {}, function (t, n) {
    t.setTime(+t + n);
  }, function (t, n) {
    return n - t;
  });

  kn.every = function (t) {
    return t = Math.floor(t), isFinite(t) && t > 0 ? t > 1 ? Nn(function (n) {
      n.setTime(Math.floor(n / t) * t);
    }, function (n, e) {
      n.setTime(+n + e * t);
    }, function (n, e) {
      return (e - n) / t;
    }) : kn : null;
  };

  var Un = Nn(function (t) {
    t.setTime(t - t.getMilliseconds());
  }, function (t, n) {
    t.setTime(+t + 1e3 * n);
  }, function (t, n) {
    return (n - t) / 1e3;
  }, function (t) {
    return t.getUTCSeconds();
  }),
      Sn = Nn(function (t) {
    t.setTime(t - t.getMilliseconds() - 1e3 * t.getSeconds());
  }, function (t, n) {
    t.setTime(+t + 6e4 * n);
  }, function (t, n) {
    return (n - t) / 6e4;
  }, function (t) {
    return t.getMinutes();
  }),
      Dn = Nn(function (t) {
    t.setTime(t - t.getMilliseconds() - 1e3 * t.getSeconds() - 6e4 * t.getMinutes());
  }, function (t, n) {
    t.setTime(+t + 36e5 * n);
  }, function (t, n) {
    return (n - t) / 36e5;
  }, function (t) {
    return t.getHours();
  }),
      Ln = Nn(function (t) {
    t.setHours(0, 0, 0, 0);
  }, function (t, n) {
    t.setDate(t.getDate() + n);
  }, function (t, n) {
    return (n - t - 6e4 * (n.getTimezoneOffset() - t.getTimezoneOffset())) / 864e5;
  }, function (t) {
    return t.getDate() - 1;
  });

  function An(t) {
    return Nn(function (n) {
      n.setDate(n.getDate() - (n.getDay() + 7 - t) % 7), n.setHours(0, 0, 0, 0);
    }, function (t, n) {
      t.setDate(t.getDate() + 7 * n);
    }, function (t, n) {
      return (n - t - 6e4 * (n.getTimezoneOffset() - t.getTimezoneOffset())) / 6048e5;
    });
  }

  var Rn = An(0),
      En = An(1),
      Pn = (An(2), An(3), An(4)),
      Fn = (An(5), An(6), Nn(function (t) {
    t.setDate(1), t.setHours(0, 0, 0, 0);
  }, function (t, n) {
    t.setMonth(t.getMonth() + n);
  }, function (t, n) {
    return n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear());
  }, function (t) {
    return t.getMonth();
  })),
      Yn = Nn(function (t) {
    t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function (t, n) {
    t.setFullYear(t.getFullYear() + n);
  }, function (t, n) {
    return n.getFullYear() - t.getFullYear();
  }, function (t) {
    return t.getFullYear();
  });

  Yn.every = function (t) {
    return isFinite(t = Math.floor(t)) && t > 0 ? Nn(function (n) {
      n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0);
    }, function (n, e) {
      n.setFullYear(n.getFullYear() + e * t);
    }) : null;
  };

  var Hn = Nn(function (t) {
    t.setUTCSeconds(0, 0);
  }, function (t, n) {
    t.setTime(+t + 6e4 * n);
  }, function (t, n) {
    return (n - t) / 6e4;
  }, function (t) {
    return t.getUTCMinutes();
  }),
      qn = Nn(function (t) {
    t.setUTCMinutes(0, 0, 0);
  }, function (t, n) {
    t.setTime(+t + 36e5 * n);
  }, function (t, n) {
    return (n - t) / 36e5;
  }, function (t) {
    return t.getUTCHours();
  }),
      zn = Nn(function (t) {
    t.setUTCHours(0, 0, 0, 0);
  }, function (t, n) {
    t.setUTCDate(t.getUTCDate() + n);
  }, function (t, n) {
    return (n - t) / 864e5;
  }, function (t) {
    return t.getUTCDate() - 1;
  });

  function jn(t) {
    return Nn(function (n) {
      n.setUTCDate(n.getUTCDate() - (n.getUTCDay() + 7 - t) % 7), n.setUTCHours(0, 0, 0, 0);
    }, function (t, n) {
      t.setUTCDate(t.getUTCDate() + 7 * n);
    }, function (t, n) {
      return (n - t) / 6048e5;
    });
  }

  var On = jn(0),
      Zn = jn(1),
      In = (jn(2), jn(3), jn(4)),
      $n = (jn(5), jn(6), Nn(function (t) {
    t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0);
  }, function (t, n) {
    t.setUTCMonth(t.getUTCMonth() + n);
  }, function (t, n) {
    return n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear());
  }, function (t) {
    return t.getUTCMonth();
  })),
      Vn = Nn(function (t) {
    t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function (t, n) {
    t.setUTCFullYear(t.getUTCFullYear() + n);
  }, function (t, n) {
    return n.getUTCFullYear() - t.getUTCFullYear();
  }, function (t) {
    return t.getUTCFullYear();
  });

  function Bn(t) {
    if (0 <= t.y && t.y < 100) {
      var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
      return n.setFullYear(t.y), n;
    }

    return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
  }

  function Xn(t) {
    if (0 <= t.y && t.y < 100) {
      var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
      return n.setUTCFullYear(t.y), n;
    }

    return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
  }

  function Wn(t, n, e) {
    return {
      y: t,
      m: n,
      d: e,
      H: 0,
      M: 0,
      S: 0,
      L: 0
    };
  }

  Vn.every = function (t) {
    return isFinite(t = Math.floor(t)) && t > 0 ? Nn(function (n) {
      n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0);
    }, function (n, e) {
      n.setUTCFullYear(n.getUTCFullYear() + e * t);
    }) : null;
  };

  var Qn,
      Jn,
      Gn,
      Kn = {
    "-": "",
    _: " ",
    0: "0"
  },
      te = /^\s*\d+/,
      ne = /^%/,
      ee = /[\\^$*+?|[\]().{}]/g;

  function ie(t, n, e) {
    var i = t < 0 ? "-" : "",
        r = (i ? -t : t) + "",
        o = r.length;
    return i + (o < e ? new Array(e - o + 1).join(n) + r : r);
  }

  function re(t) {
    return t.replace(ee, "\\$&");
  }

  function oe(t) {
    return new RegExp("^(?:" + t.map(re).join("|") + ")", "i");
  }

  function se(t) {
    for (var n = {}, e = -1, i = t.length; ++e < i;) {
      n[t[e].toLowerCase()] = e;
    }

    return n;
  }

  function ue(t, n, e) {
    var i = te.exec(n.slice(e, e + 1));
    return i ? (t.w = +i[0], e + i[0].length) : -1;
  }

  function ae(t, n, e) {
    var i = te.exec(n.slice(e, e + 1));
    return i ? (t.u = +i[0], e + i[0].length) : -1;
  }

  function he(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.U = +i[0], e + i[0].length) : -1;
  }

  function ce(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.V = +i[0], e + i[0].length) : -1;
  }

  function le(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.W = +i[0], e + i[0].length) : -1;
  }

  function fe(t, n, e) {
    var i = te.exec(n.slice(e, e + 4));
    return i ? (t.y = +i[0], e + i[0].length) : -1;
  }

  function _e(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), e + i[0].length) : -1;
  }

  function ye(t, n, e) {
    var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e, e + 6));
    return i ? (t.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), e + i[0].length) : -1;
  }

  function ge(t, n, e) {
    var i = te.exec(n.slice(e, e + 1));
    return i ? (t.q = 3 * i[0] - 3, e + i[0].length) : -1;
  }

  function pe(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.m = i[0] - 1, e + i[0].length) : -1;
  }

  function xe(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.d = +i[0], e + i[0].length) : -1;
  }

  function de(t, n, e) {
    var i = te.exec(n.slice(e, e + 3));
    return i ? (t.m = 0, t.d = +i[0], e + i[0].length) : -1;
  }

  function ve(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.H = +i[0], e + i[0].length) : -1;
  }

  function me(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.M = +i[0], e + i[0].length) : -1;
  }

  function Me(t, n, e) {
    var i = te.exec(n.slice(e, e + 2));
    return i ? (t.S = +i[0], e + i[0].length) : -1;
  }

  function we(t, n, e) {
    var i = te.exec(n.slice(e, e + 3));
    return i ? (t.L = +i[0], e + i[0].length) : -1;
  }

  function be(t, n, e) {
    var i = te.exec(n.slice(e, e + 6));
    return i ? (t.L = Math.floor(i[0] / 1e3), e + i[0].length) : -1;
  }

  function Te(t, n, e) {
    var i = ne.exec(n.slice(e, e + 1));
    return i ? e + i[0].length : -1;
  }

  function Ce(t, n, e) {
    var i = te.exec(n.slice(e));
    return i ? (t.Q = +i[0], e + i[0].length) : -1;
  }

  function Ne(t, n, e) {
    var i = te.exec(n.slice(e));
    return i ? (t.s = +i[0], e + i[0].length) : -1;
  }

  function ke(t, n) {
    return ie(t.getDate(), n, 2);
  }

  function Ue(t, n) {
    return ie(t.getHours(), n, 2);
  }

  function Se(t, n) {
    return ie(t.getHours() % 12 || 12, n, 2);
  }

  function De(t, n) {
    return ie(1 + Ln.count(Yn(t), t), n, 3);
  }

  function Le(t, n) {
    return ie(t.getMilliseconds(), n, 3);
  }

  function Ae(t, n) {
    return Le(t, n) + "000";
  }

  function Re(t, n) {
    return ie(t.getMonth() + 1, n, 2);
  }

  function Ee(t, n) {
    return ie(t.getMinutes(), n, 2);
  }

  function Pe(t, n) {
    return ie(t.getSeconds(), n, 2);
  }

  function Fe(t) {
    var n = t.getDay();
    return 0 === n ? 7 : n;
  }

  function Ye(t, n) {
    return ie(Rn.count(Yn(t) - 1, t), n, 2);
  }

  function He(t, n) {
    var e = t.getDay();
    return t = e >= 4 || 0 === e ? Pn(t) : Pn.ceil(t), ie(Pn.count(Yn(t), t) + (4 === Yn(t).getDay()), n, 2);
  }

  function qe(t) {
    return t.getDay();
  }

  function ze(t, n) {
    return ie(En.count(Yn(t) - 1, t), n, 2);
  }

  function je(t, n) {
    return ie(t.getFullYear() % 100, n, 2);
  }

  function Oe(t, n) {
    return ie(t.getFullYear() % 1e4, n, 4);
  }

  function Ze(t) {
    var n = t.getTimezoneOffset();
    return (n > 0 ? "-" : (n *= -1, "+")) + ie(n / 60 | 0, "0", 2) + ie(n % 60, "0", 2);
  }

  function Ie(t, n) {
    return ie(t.getUTCDate(), n, 2);
  }

  function $e(t, n) {
    return ie(t.getUTCHours(), n, 2);
  }

  function Ve(t, n) {
    return ie(t.getUTCHours() % 12 || 12, n, 2);
  }

  function Be(t, n) {
    return ie(1 + zn.count(Vn(t), t), n, 3);
  }

  function Xe(t, n) {
    return ie(t.getUTCMilliseconds(), n, 3);
  }

  function We(t, n) {
    return Xe(t, n) + "000";
  }

  function Qe(t, n) {
    return ie(t.getUTCMonth() + 1, n, 2);
  }

  function Je(t, n) {
    return ie(t.getUTCMinutes(), n, 2);
  }

  function Ge(t, n) {
    return ie(t.getUTCSeconds(), n, 2);
  }

  function Ke(t) {
    var n = t.getUTCDay();
    return 0 === n ? 7 : n;
  }

  function ti(t, n) {
    return ie(On.count(Vn(t) - 1, t), n, 2);
  }

  function ni(t, n) {
    var e = t.getUTCDay();
    return t = e >= 4 || 0 === e ? In(t) : In.ceil(t), ie(In.count(Vn(t), t) + (4 === Vn(t).getUTCDay()), n, 2);
  }

  function ei(t) {
    return t.getUTCDay();
  }

  function ii(t, n) {
    return ie(Zn.count(Vn(t) - 1, t), n, 2);
  }

  function ri(t, n) {
    return ie(t.getUTCFullYear() % 100, n, 2);
  }

  function oi(t, n) {
    return ie(t.getUTCFullYear() % 1e4, n, 4);
  }

  function si() {
    return "+0000";
  }

  function ui() {
    return "%";
  }

  function ai(t) {
    return +t;
  }

  function hi(t) {
    return Math.floor(+t / 1e3);
  }

  !function (t) {
    Qn = function (t) {
      var n = t.dateTime,
          e = t.date,
          i = t.time,
          r = t.periods,
          o = t.days,
          s = t.shortDays,
          u = t.months,
          a = t.shortMonths,
          h = oe(r),
          c = se(r),
          l = oe(o),
          f = se(o),
          _ = oe(s),
          y = se(s),
          g = oe(u),
          p = se(u),
          x = oe(a),
          d = se(a),
          v = {
        a: function a(t) {
          return s[t.getDay()];
        },
        A: function A(t) {
          return o[t.getDay()];
        },
        b: function b(t) {
          return a[t.getMonth()];
        },
        B: function B(t) {
          return u[t.getMonth()];
        },
        c: null,
        d: ke,
        e: ke,
        f: Ae,
        H: Ue,
        I: Se,
        j: De,
        L: Le,
        m: Re,
        M: Ee,
        p: function p(t) {
          return r[+(t.getHours() >= 12)];
        },
        q: function q(t) {
          return 1 + ~~(t.getMonth() / 3);
        },
        Q: ai,
        s: hi,
        S: Pe,
        u: Fe,
        U: Ye,
        V: He,
        w: qe,
        W: ze,
        x: null,
        X: null,
        y: je,
        Y: Oe,
        Z: Ze,
        "%": ui
      },
          m = {
        a: function a(t) {
          return s[t.getUTCDay()];
        },
        A: function A(t) {
          return o[t.getUTCDay()];
        },
        b: function b(t) {
          return a[t.getUTCMonth()];
        },
        B: function B(t) {
          return u[t.getUTCMonth()];
        },
        c: null,
        d: Ie,
        e: Ie,
        f: We,
        H: $e,
        I: Ve,
        j: Be,
        L: Xe,
        m: Qe,
        M: Je,
        p: function p(t) {
          return r[+(t.getUTCHours() >= 12)];
        },
        q: function q(t) {
          return 1 + ~~(t.getUTCMonth() / 3);
        },
        Q: ai,
        s: hi,
        S: Ge,
        u: Ke,
        U: ti,
        V: ni,
        w: ei,
        W: ii,
        x: null,
        X: null,
        y: ri,
        Y: oi,
        Z: si,
        "%": ui
      },
          M = {
        a: function a(t, n, e) {
          var i = _.exec(n.slice(e));

          return i ? (t.w = y[i[0].toLowerCase()], e + i[0].length) : -1;
        },
        A: function A(t, n, e) {
          var i = l.exec(n.slice(e));
          return i ? (t.w = f[i[0].toLowerCase()], e + i[0].length) : -1;
        },
        b: function b(t, n, e) {
          var i = x.exec(n.slice(e));
          return i ? (t.m = d[i[0].toLowerCase()], e + i[0].length) : -1;
        },
        B: function B(t, n, e) {
          var i = g.exec(n.slice(e));
          return i ? (t.m = p[i[0].toLowerCase()], e + i[0].length) : -1;
        },
        c: function c(t, e, i) {
          return T(t, n, e, i);
        },
        d: xe,
        e: xe,
        f: be,
        H: ve,
        I: ve,
        j: de,
        L: we,
        m: pe,
        M: me,
        p: function p(t, n, e) {
          var i = h.exec(n.slice(e));
          return i ? (t.p = c[i[0].toLowerCase()], e + i[0].length) : -1;
        },
        q: ge,
        Q: Ce,
        s: Ne,
        S: Me,
        u: ae,
        U: he,
        V: ce,
        w: ue,
        W: le,
        x: function x(t, n, i) {
          return T(t, e, n, i);
        },
        X: function X(t, n, e) {
          return T(t, i, n, e);
        },
        y: _e,
        Y: fe,
        Z: ye,
        "%": Te
      };

      function w(t, n) {
        return function (e) {
          var i,
              r,
              o,
              s = [],
              u = -1,
              a = 0,
              h = t.length;

          for (e instanceof Date || (e = new Date(+e)); ++u < h;) {
            37 === t.charCodeAt(u) && (s.push(t.slice(a, u)), null != (r = Kn[i = t.charAt(++u)]) ? i = t.charAt(++u) : r = "e" === i ? " " : "0", (o = n[i]) && (i = o(e, r)), s.push(i), a = u + 1);
          }

          return s.push(t.slice(a, u)), s.join("");
        };
      }

      function b(t, n) {
        return function (e) {
          var i,
              r,
              o = Wn(1900, void 0, 1);
          if (T(o, t, e += "", 0) != e.length) return null;
          if ("Q" in o) return new Date(o.Q);
          if ("s" in o) return new Date(1e3 * o.s + ("L" in o ? o.L : 0));

          if (n && !("Z" in o) && (o.Z = 0), "p" in o && (o.H = o.H % 12 + 12 * o.p), void 0 === o.m && (o.m = "q" in o ? o.q : 0), "V" in o) {
            if (o.V < 1 || o.V > 53) return null;
            "w" in o || (o.w = 1), "Z" in o ? (r = (i = Xn(Wn(o.y, 0, 1))).getUTCDay(), i = r > 4 || 0 === r ? Zn.ceil(i) : Zn(i), i = zn.offset(i, 7 * (o.V - 1)), o.y = i.getUTCFullYear(), o.m = i.getUTCMonth(), o.d = i.getUTCDate() + (o.w + 6) % 7) : (r = (i = Bn(Wn(o.y, 0, 1))).getDay(), i = r > 4 || 0 === r ? En.ceil(i) : En(i), i = Ln.offset(i, 7 * (o.V - 1)), o.y = i.getFullYear(), o.m = i.getMonth(), o.d = i.getDate() + (o.w + 6) % 7);
          } else ("W" in o || "U" in o) && ("w" in o || (o.w = "u" in o ? o.u % 7 : "W" in o ? 1 : 0), r = "Z" in o ? Xn(Wn(o.y, 0, 1)).getUTCDay() : Bn(Wn(o.y, 0, 1)).getDay(), o.m = 0, o.d = "W" in o ? (o.w + 6) % 7 + 7 * o.W - (r + 5) % 7 : o.w + 7 * o.U - (r + 6) % 7);

          return "Z" in o ? (o.H += o.Z / 100 | 0, o.M += o.Z % 100, Xn(o)) : Bn(o);
        };
      }

      function T(t, n, e, i) {
        for (var r, o, s = 0, u = n.length, a = e.length; s < u;) {
          if (i >= a) return -1;

          if (37 === (r = n.charCodeAt(s++))) {
            if (r = n.charAt(s++), !(o = M[r in Kn ? n.charAt(s++) : r]) || (i = o(t, e, i)) < 0) return -1;
          } else if (r != e.charCodeAt(i++)) return -1;
        }

        return i;
      }

      return v.x = w(e, v), v.X = w(i, v), v.c = w(n, v), m.x = w(e, m), m.X = w(i, m), m.c = w(n, m), {
        format: function format(t) {
          var n = w(t += "", v);
          return n.toString = function () {
            return t;
          }, n;
        },
        parse: function parse(t) {
          var n = b(t += "", !1);
          return n.toString = function () {
            return t;
          }, n;
        },
        utcFormat: function utcFormat(t) {
          var n = w(t += "", m);
          return n.toString = function () {
            return t;
          }, n;
        },
        utcParse: function utcParse(t) {
          var n = b(t += "", !0);
          return n.toString = function () {
            return t;
          }, n;
        }
      };
    }(t), Jn = Qn.format, Qn.parse, Gn = Qn.utcFormat, Qn.utcParse;
  }({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  function ci(t) {
    return new Date(t);
  }

  function li(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }

  function fi(t, n, e, i, r, o, s, u, a) {
    var h = Wt(),
        c = h.invert,
        l = h.domain,
        f = a(".%L"),
        _ = a(":%S"),
        y = a("%I:%M"),
        g = a("%I %p"),
        p = a("%a %d"),
        x = a("%b %d"),
        d = a("%B"),
        v = a("%Y"),
        m = [[s, 1, 1e3], [s, 5, 5e3], [s, 15, 15e3], [s, 30, 3e4], [o, 1, 6e4], [o, 5, 3e5], [o, 15, 9e5], [o, 30, 18e5], [r, 1, 36e5], [r, 3, 108e5], [r, 6, 216e5], [r, 12, 432e5], [i, 1, 864e5], [i, 2, 1728e5], [e, 1, 6048e5], [n, 1, 2592e6], [n, 3, 7776e6], [t, 1, 31536e6]];

    function M(u) {
      return (s(u) < u ? f : o(u) < u ? _ : r(u) < u ? y : i(u) < u ? g : n(u) < u ? e(u) < u ? p : x : t(u) < u ? d : v)(u);
    }

    function w(n, e, i) {
      if (null == n && (n = 10), "number" == typeof n) {
        var r,
            o = Math.abs(i - e) / n,
            s = q(function (t) {
          return t[2];
        }).right(m, o);
        return s === m.length ? (r = B(e / 31536e6, i / 31536e6, n), n = t) : s ? (r = (s = m[o / m[s - 1][2] < m[s][2] / o ? s - 1 : s])[1], n = s[0]) : (r = Math.max(B(e, i, n), 1), n = u), n.every(r);
      }

      return n;
    }

    return h.invert = function (t) {
      return new Date(c(t));
    }, h.domain = function (t) {
      return arguments.length ? l(Array.from(t, li)) : l().map(ci);
    }, h.ticks = function (t) {
      var n,
          e = l(),
          i = e[0],
          r = e[e.length - 1],
          o = r < i;
      return o && (n = i, i = r, r = n), n = (n = w(t, i, r)) ? n.range(i, r + 1) : [], o ? n.reverse() : n;
    }, h.tickFormat = function (t, n) {
      return null == n ? M : a(n);
    }, h.nice = function (t) {
      var n = l();
      return (t = w(t, n[0], n[n.length - 1])) ? l(gn(n, t)) : h;
    }, h.copy = function () {
      return Bt(h, fi(t, n, e, i, r, o, s, u, a));
    }, h;
  }

  function _i() {
    return X.apply(fi(Yn, Fn, Rn, Ln, Dn, Sn, Un, kn, Jn).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }

  function yi() {
    return X.apply(fi(Vn, $n, On, zn, qn, Hn, Un, kn, Gn).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }

  var gi = Math.PI,
      pi = 2 * gi,
      xi = pi - 1e-6;

  function di() {
    this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
  }

  function vi() {
    return new di();
  }

  function mi(t) {
    return function () {
      return t;
    };
  }

  di.prototype = vi.prototype = {
    constructor: di,
    moveTo: function moveTo(t, n) {
      this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +n);
    },
    closePath: function closePath() {
      null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
    },
    lineTo: function lineTo(t, n) {
      this._ += "L" + (this._x1 = +t) + "," + (this._y1 = +n);
    },
    quadraticCurveTo: function quadraticCurveTo(t, n, e, i) {
      this._ += "Q" + +t + "," + +n + "," + (this._x1 = +e) + "," + (this._y1 = +i);
    },
    bezierCurveTo: function bezierCurveTo(t, n, e, i, r, o) {
      this._ += "C" + +t + "," + +n + "," + +e + "," + +i + "," + (this._x1 = +r) + "," + (this._y1 = +o);
    },
    arcTo: function arcTo(t, n, e, i, r) {
      t = +t, n = +n, e = +e, i = +i, r = +r;
      var o = this._x1,
          s = this._y1,
          u = e - t,
          a = i - n,
          h = o - t,
          c = s - n,
          l = h * h + c * c;
      if (r < 0) throw new Error("negative radius: " + r);
      if (null === this._x1) this._ += "M" + (this._x1 = t) + "," + (this._y1 = n);else if (l > 1e-6) {
        if (Math.abs(c * u - a * h) > 1e-6 && r) {
          var f = e - o,
              _ = i - s,
              y = u * u + a * a,
              g = f * f + _ * _,
              p = Math.sqrt(y),
              x = Math.sqrt(l),
              d = r * Math.tan((gi - Math.acos((y + l - g) / (2 * p * x))) / 2),
              v = d / x,
              m = d / p;

          Math.abs(v - 1) > 1e-6 && (this._ += "L" + (t + v * h) + "," + (n + v * c)), this._ += "A" + r + "," + r + ",0,0," + +(c * f > h * _) + "," + (this._x1 = t + m * u) + "," + (this._y1 = n + m * a);
        } else this._ += "L" + (this._x1 = t) + "," + (this._y1 = n);
      }
    },
    arc: function arc(t, n, e, i, r, o) {
      t = +t, n = +n, o = !!o;
      var s = (e = +e) * Math.cos(i),
          u = e * Math.sin(i),
          a = t + s,
          h = n + u,
          c = 1 ^ o,
          l = o ? i - r : r - i;
      if (e < 0) throw new Error("negative radius: " + e);
      null === this._x1 ? this._ += "M" + a + "," + h : (Math.abs(this._x1 - a) > 1e-6 || Math.abs(this._y1 - h) > 1e-6) && (this._ += "L" + a + "," + h), e && (l < 0 && (l = l % pi + pi), l > xi ? this._ += "A" + e + "," + e + ",0,1," + c + "," + (t - s) + "," + (n - u) + "A" + e + "," + e + ",0,1," + c + "," + (this._x1 = a) + "," + (this._y1 = h) : l > 1e-6 && (this._ += "A" + e + "," + e + ",0," + +(l >= gi) + "," + c + "," + (this._x1 = t + e * Math.cos(r)) + "," + (this._y1 = n + e * Math.sin(r))));
    },
    rect: function rect(t, n, e, i) {
      this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +n) + "h" + +e + "v" + +i + "h" + -e + "Z";
    },
    toString: function toString() {
      return this._;
    }
  };

  function ji(t) {
    this._context = t;
  }

  function Oi(t) {
    return new ji(t);
  }

  function Zi(t) {
    return t[0];
  }

  function Ii(t) {
    return t[1];
  }

  function $i() {
    var t = Zi,
        n = Ii,
        e = mi(!0),
        i = null,
        r = Oi,
        o = null;

    function s(s) {
      var u,
          a,
          h,
          c = s.length,
          l = !1;

      for (null == i && (o = r(h = vi())), u = 0; u <= c; ++u) {
        !(u < c && e(a = s[u], u, s)) === l && ((l = !l) ? o.lineStart() : o.lineEnd()), l && o.point(+t(a, u, s), +n(a, u, s));
      }

      if (h) return o = null, h + "" || null;
    }

    return s.x = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : mi(+n), s) : t;
    }, s.y = function (t) {
      return arguments.length ? (n = "function" == typeof t ? t : mi(+t), s) : n;
    }, s.defined = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : mi(!!t), s) : e;
    }, s.curve = function (t) {
      return arguments.length ? (r = t, null != i && (o = r(i)), s) : r;
    }, s.context = function (t) {
      return arguments.length ? (null == t ? i = o = null : o = r(i = t), s) : i;
    }, s;
  }

  function Vi() {
    var t = Zi,
        n = null,
        e = mi(0),
        i = Ii,
        r = mi(!0),
        o = null,
        s = Oi,
        u = null;

    function a(a) {
      var h,
          c,
          l,
          f,
          _,
          y = a.length,
          g = !1,
          p = new Array(y),
          x = new Array(y);

      for (null == o && (u = s(_ = vi())), h = 0; h <= y; ++h) {
        if (!(h < y && r(f = a[h], h, a)) === g) if (g = !g) c = h, u.areaStart(), u.lineStart();else {
          for (u.lineEnd(), u.lineStart(), l = h - 1; l >= c; --l) {
            u.point(p[l], x[l]);
          }

          u.lineEnd(), u.areaEnd();
        }
        g && (p[h] = +t(f, h, a), x[h] = +e(f, h, a), u.point(n ? +n(f, h, a) : p[h], i ? +i(f, h, a) : x[h]));
      }

      if (_) return u = null, _ + "" || null;
    }

    function h() {
      return $i().defined(r).curve(s).context(o);
    }

    return a.x = function (e) {
      return arguments.length ? (t = "function" == typeof e ? e : mi(+e), n = null, a) : t;
    }, a.x0 = function (n) {
      return arguments.length ? (t = "function" == typeof n ? n : mi(+n), a) : t;
    }, a.x1 = function (t) {
      return arguments.length ? (n = null == t ? null : "function" == typeof t ? t : mi(+t), a) : n;
    }, a.y = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : mi(+t), i = null, a) : e;
    }, a.y0 = function (t) {
      return arguments.length ? (e = "function" == typeof t ? t : mi(+t), a) : e;
    }, a.y1 = function (t) {
      return arguments.length ? (i = null == t ? null : "function" == typeof t ? t : mi(+t), a) : i;
    }, a.lineX0 = a.lineY0 = function () {
      return h().x(t).y(e);
    }, a.lineY1 = function () {
      return h().x(t).y(i);
    }, a.lineX1 = function () {
      return h().x(n).y(e);
    }, a.defined = function (t) {
      return arguments.length ? (r = "function" == typeof t ? t : mi(!!t), a) : r;
    }, a.curve = function (t) {
      return arguments.length ? (s = t, null != o && (u = s(o)), a) : s;
    }, a.context = function (t) {
      return arguments.length ? (null == t ? o = u = null : u = s(o = t), a) : o;
    }, a;
  }

  function Qi() {}

  function Ji(t, n, e) {
    t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + n) / 6, (t._y0 + 4 * t._y1 + e) / 6);
  }

  function Gi(t) {
    this._context = t;
  }

  function Ki(t) {
    return new Gi(t);
  }

  function tr(t) {
    this._context = t;
  }

  function nr(t) {
    return new tr(t);
  }

  function er(t) {
    this._context = t;
  }

  function ir(t) {
    return new er(t);
  }

  function rr(t, n) {
    this._basis = new Gi(t), this._beta = n;
  }

  ji.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._point = 0;
    },
    lineEnd: function lineEnd() {
      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;

        case 1:
          this._point = 2;

        default:
          this._context.lineTo(t, n);

      }
    }
  }, Gi.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
    },
    lineEnd: function lineEnd() {
      switch (this._point) {
        case 3:
          Ji(this, this._x1, this._y1);

        case 2:
          this._context.lineTo(this._x1, this._y1);

      }

      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;

        case 1:
          this._point = 2;
          break;

        case 2:
          this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);

        default:
          Ji(this, t, n);
      }

      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n;
    }
  }, tr.prototype = {
    areaStart: Qi,
    areaEnd: Qi,
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
    },
    lineEnd: function lineEnd() {
      switch (this._point) {
        case 1:
          this._context.moveTo(this._x2, this._y2), this._context.closePath();
          break;

        case 2:
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
          break;

        case 3:
          this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
      }
    },
    point: function point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._x2 = t, this._y2 = n;
          break;

        case 1:
          this._point = 2, this._x3 = t, this._y3 = n;
          break;

        case 2:
          this._point = 3, this._x4 = t, this._y4 = n, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6);
          break;

        default:
          Ji(this, t, n);
      }

      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n;
    }
  }, er.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
    },
    lineEnd: function lineEnd() {
      (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1;
          break;

        case 1:
          this._point = 2;
          break;

        case 2:
          this._point = 3;
          var e = (this._x0 + 4 * this._x1 + t) / 6,
              i = (this._y0 + 4 * this._y1 + n) / 6;
          this._line ? this._context.lineTo(e, i) : this._context.moveTo(e, i);
          break;

        case 3:
          this._point = 4;

        default:
          Ji(this, t, n);
      }

      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n;
    }
  }, rr.prototype = {
    lineStart: function lineStart() {
      this._x = [], this._y = [], this._basis.lineStart();
    },
    lineEnd: function lineEnd() {
      var t = this._x,
          n = this._y,
          e = t.length - 1;
      if (e > 0) for (var i, r = t[0], o = n[0], s = t[e] - r, u = n[e] - o, a = -1; ++a <= e;) {
        i = a / e, this._basis.point(this._beta * t[a] + (1 - this._beta) * (r + i * s), this._beta * n[a] + (1 - this._beta) * (o + i * u));
      }
      this._x = this._y = null, this._basis.lineEnd();
    },
    point: function point(t, n) {
      this._x.push(+t), this._y.push(+n);
    }
  };

  var or = function t(n) {
    function e(t) {
      return 1 === n ? new Gi(t) : new rr(t, n);
    }

    return e.beta = function (n) {
      return t(+n);
    }, e;
  }(.85);

  function sr(t, n, e) {
    t._context.bezierCurveTo(t._x1 + t._k * (t._x2 - t._x0), t._y1 + t._k * (t._y2 - t._y0), t._x2 + t._k * (t._x1 - n), t._y2 + t._k * (t._y1 - e), t._x2, t._y2);
  }

  function ur(t, n) {
    this._context = t, this._k = (1 - n) / 6;
  }

  ur.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
    },
    lineEnd: function lineEnd() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);

          break;

        case 3:
          sr(this, this._x1, this._y1);
      }

      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;

        case 1:
          this._point = 2, this._x1 = t, this._y1 = n;
          break;

        case 2:
          this._point = 3;

        default:
          sr(this, t, n);
      }

      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };

  var ar = function t(n) {
    function e(t) {
      return new ur(t, n);
    }

    return e.tension = function (n) {
      return t(+n);
    }, e;
  }(0);

  function hr(t, n) {
    this._context = t, this._k = (1 - n) / 6;
  }

  hr.prototype = {
    areaStart: Qi,
    areaEnd: Qi,
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
    },
    lineEnd: function lineEnd() {
      switch (this._point) {
        case 1:
          this._context.moveTo(this._x3, this._y3), this._context.closePath();
          break;

        case 2:
          this._context.lineTo(this._x3, this._y3), this._context.closePath();
          break;

        case 3:
          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
      }
    },
    point: function point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._x3 = t, this._y3 = n;
          break;

        case 1:
          this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n);
          break;

        case 2:
          this._point = 3, this._x5 = t, this._y5 = n;
          break;

        default:
          sr(this, t, n);
      }

      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };

  var cr = function t(n) {
    function e(t) {
      return new hr(t, n);
    }

    return e.tension = function (n) {
      return t(+n);
    }, e;
  }(0);

  function lr(t, n) {
    this._context = t, this._k = (1 - n) / 6;
  }

  lr.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
    },
    lineEnd: function lineEnd() {
      (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1;
          break;

        case 1:
          this._point = 2;
          break;

        case 2:
          this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;

        case 3:
          this._point = 4;

        default:
          sr(this, t, n);
      }

      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };

  var fr = function t(n) {
    function e(t) {
      return new lr(t, n);
    }

    return e.tension = function (n) {
      return t(+n);
    }, e;
  }(0);

  function _r(t, n, e) {
    var i = t._x1,
        r = t._y1,
        o = t._x2,
        s = t._y2;

    if (t._l01_a > 1e-12) {
      var u = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a,
          a = 3 * t._l01_a * (t._l01_a + t._l12_a);
      i = (i * u - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / a, r = (r * u - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / a;
    }

    if (t._l23_a > 1e-12) {
      var h = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a,
          c = 3 * t._l23_a * (t._l23_a + t._l12_a);
      o = (o * h + t._x1 * t._l23_2a - n * t._l12_2a) / c, s = (s * h + t._y1 * t._l23_2a - e * t._l12_2a) / c;
    }

    t._context.bezierCurveTo(i, r, o, s, t._x2, t._y2);
  }

  function yr(t, n) {
    this._context = t, this._alpha = n;
  }

  yr.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function lineEnd() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);

          break;

        case 3:
          this.point(this._x2, this._y2);
      }

      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function point(t, n) {
      if (t = +t, n = +n, this._point) {
        var e = this._x2 - t,
            i = this._y2 - n;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + i * i, this._alpha));
      }

      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;

        case 1:
          this._point = 2;
          break;

        case 2:
          this._point = 3;

        default:
          _r(this, t, n);

      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };

  var gr = function t(n) {
    function e(t) {
      return n ? new yr(t, n) : new ur(t, 0);
    }

    return e.alpha = function (n) {
      return t(+n);
    }, e;
  }(.5);

  function pr(t, n) {
    this._context = t, this._alpha = n;
  }

  pr.prototype = {
    areaStart: Qi,
    areaEnd: Qi,
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function lineEnd() {
      switch (this._point) {
        case 1:
          this._context.moveTo(this._x3, this._y3), this._context.closePath();
          break;

        case 2:
          this._context.lineTo(this._x3, this._y3), this._context.closePath();
          break;

        case 3:
          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
      }
    },
    point: function point(t, n) {
      if (t = +t, n = +n, this._point) {
        var e = this._x2 - t,
            i = this._y2 - n;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + i * i, this._alpha));
      }

      switch (this._point) {
        case 0:
          this._point = 1, this._x3 = t, this._y3 = n;
          break;

        case 1:
          this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = n);
          break;

        case 2:
          this._point = 3, this._x5 = t, this._y5 = n;
          break;

        default:
          _r(this, t, n);

      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };

  var xr = function t(n) {
    function e(t) {
      return n ? new pr(t, n) : new hr(t, 0);
    }

    return e.alpha = function (n) {
      return t(+n);
    }, e;
  }(.5);

  function dr(t, n) {
    this._context = t, this._alpha = n;
  }

  dr.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function lineEnd() {
      (this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function point(t, n) {
      if (t = +t, n = +n, this._point) {
        var e = this._x2 - t,
            i = this._y2 - n;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + i * i, this._alpha));
      }

      switch (this._point) {
        case 0:
          this._point = 1;
          break;

        case 1:
          this._point = 2;
          break;

        case 2:
          this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;

        case 3:
          this._point = 4;

        default:
          _r(this, t, n);

      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
    }
  };

  var vr = function t(n) {
    function e(t) {
      return n ? new dr(t, n) : new lr(t, 0);
    }

    return e.alpha = function (n) {
      return t(+n);
    }, e;
  }(.5);

  function mr(t) {
    this._context = t;
  }

  function Mr(t) {
    return new mr(t);
  }

  function wr(t) {
    return t < 0 ? -1 : 1;
  }

  function br(t, n, e) {
    var i = t._x1 - t._x0,
        r = n - t._x1,
        o = (t._y1 - t._y0) / (i || r < 0 && -0),
        s = (e - t._y1) / (r || i < 0 && -0),
        u = (o * r + s * i) / (i + r);
    return (wr(o) + wr(s)) * Math.min(Math.abs(o), Math.abs(s), .5 * Math.abs(u)) || 0;
  }

  function Tr(t, n) {
    var e = t._x1 - t._x0;
    return e ? (3 * (t._y1 - t._y0) / e - n) / 2 : n;
  }

  function Cr(t, n, e) {
    var i = t._x0,
        r = t._y0,
        o = t._x1,
        s = t._y1,
        u = (o - i) / 3;

    t._context.bezierCurveTo(i + u, r + u * n, o - u, s - u * e, o, s);
  }

  function Nr(t) {
    this._context = t;
  }

  function kr(t) {
    this._context = new Ur(t);
  }

  function Ur(t) {
    this._context = t;
  }

  function Sr(t) {
    return new Nr(t);
  }

  function Dr(t) {
    return new kr(t);
  }

  function Lr(t) {
    this._context = t;
  }

  function Ar(t) {
    var n,
        e,
        i = t.length - 1,
        r = new Array(i),
        o = new Array(i),
        s = new Array(i);

    for (r[0] = 0, o[0] = 2, s[0] = t[0] + 2 * t[1], n = 1; n < i - 1; ++n) {
      r[n] = 1, o[n] = 4, s[n] = 4 * t[n] + 2 * t[n + 1];
    }

    for (r[i - 1] = 2, o[i - 1] = 7, s[i - 1] = 8 * t[i - 1] + t[i], n = 1; n < i; ++n) {
      e = r[n] / o[n - 1], o[n] -= e, s[n] -= e * s[n - 1];
    }

    for (r[i - 1] = s[i - 1] / o[i - 1], n = i - 2; n >= 0; --n) {
      r[n] = (s[n] - r[n + 1]) / o[n];
    }

    for (o[i - 1] = (t[i] + r[i - 1]) / 2, n = 0; n < i - 1; ++n) {
      o[n] = 2 * t[n + 1] - r[n + 1];
    }

    return [r, o];
  }

  function Rr(t) {
    return new Lr(t);
  }

  function Er(t, n) {
    this._context = t, this._t = n;
  }

  function Pr(t) {
    return new Er(t, .5);
  }

  function Fr(t) {
    return new Er(t, 0);
  }

  function Yr(t) {
    return new Er(t, 1);
  }

  mr.prototype = {
    areaStart: Qi,
    areaEnd: Qi,
    lineStart: function lineStart() {
      this._point = 0;
    },
    lineEnd: function lineEnd() {
      this._point && this._context.closePath();
    },
    point: function point(t, n) {
      t = +t, n = +n, this._point ? this._context.lineTo(t, n) : (this._point = 1, this._context.moveTo(t, n));
    }
  }, Nr.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
    },
    lineEnd: function lineEnd() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);

          break;

        case 3:
          Cr(this, this._t0, Tr(this, this._t0));
      }

      (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function point(t, n) {
      var e = NaN;

      if (n = +n, (t = +t) !== this._x1 || n !== this._y1) {
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
            break;

          case 1:
            this._point = 2;
            break;

          case 2:
            this._point = 3, Cr(this, Tr(this, e = br(this, t, n)), e);
            break;

          default:
            Cr(this, this._t0, e = br(this, t, n));
        }

        this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = n, this._t0 = e;
      }
    }
  }, (kr.prototype = Object.create(Nr.prototype)).point = function (t, n) {
    Nr.prototype.point.call(this, n, t);
  }, Ur.prototype = {
    moveTo: function moveTo(t, n) {
      this._context.moveTo(n, t);
    },
    closePath: function closePath() {
      this._context.closePath();
    },
    lineTo: function lineTo(t, n) {
      this._context.lineTo(n, t);
    },
    bezierCurveTo: function bezierCurveTo(t, n, e, i, r, o) {
      this._context.bezierCurveTo(n, t, i, e, o, r);
    }
  }, Lr.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x = [], this._y = [];
    },
    lineEnd: function lineEnd() {
      var t = this._x,
          n = this._y,
          e = t.length;
      if (e) if (this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), 2 === e) this._context.lineTo(t[1], n[1]);else for (var i = Ar(t), r = Ar(n), o = 0, s = 1; s < e; ++o, ++s) {
        this._context.bezierCurveTo(i[0][o], r[0][o], i[1][o], r[1][o], t[s], n[s]);
      }
      (this._line || 0 !== this._line && 1 === e) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
    },
    point: function point(t, n) {
      this._x.push(+t), this._y.push(+n);
    }
  }, Er.prototype = {
    areaStart: function areaStart() {
      this._line = 0;
    },
    areaEnd: function areaEnd() {
      this._line = NaN;
    },
    lineStart: function lineStart() {
      this._x = this._y = NaN, this._point = 0;
    },
    lineEnd: function lineEnd() {
      0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y), (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
    },
    point: function point(t, n) {
      switch (t = +t, n = +n, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;

        case 1:
          this._point = 2;

        default:
          if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n);else {
            var e = this._x * (1 - this._t) + t * this._t;
            this._context.lineTo(e, this._y), this._context.lineTo(e, n);
          }
      }

      this._x = t, this._y = n;
    }
  };

  var defaultStyle$1 = {
    strokeWidth: 2,
    stroke: "#6b6b6b",
    fill: "transparent",
    opacity: 1
  };
  function Path(_ref) {
    var style = _ref.style,
        rest = _objectWithoutProperties(_ref, ["style"]);

    var resolvedStyle = _objectSpread2({}, defaultStyle$1, {}, style);

    return /*#__PURE__*/React.createElement("path", _extends({}, rest, {
      style: resolvedStyle
    }));
  }

  var lineFn = $i();

  var VoronoiElement = function VoronoiElement(_ref) {
    var children = _ref.children,
        rest = _objectWithoutProperties(_ref, ["children"]);

    return /*#__PURE__*/React.createElement("g", _extends({
      className: "Voronoi"
    }, rest), children);
  };

  function Voronoi() {
    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 2),
        _React$useContext2$ = _React$useContext2[0],
        stackData = _React$useContext2$.stackData,
        primaryAxes = _React$useContext2$.primaryAxes,
        secondaryAxes = _React$useContext2$.secondaryAxes,
        showVoronoi = _React$useContext2$.showVoronoi,
        width = _React$useContext2$.width,
        height = _React$useContext2$.height,
        gridWidth = _React$useContext2$.gridWidth,
        gridHeight = _React$useContext2$.gridHeight,
        onFocus = _React$useContext2$.onFocus,
        onClick = _React$useContext2$.onClick,
        tooltip = _React$useContext2$.tooltip,
        primaryCursor = _React$useContext2$.primaryCursor,
        secondaryCursor = _React$useContext2$.secondaryCursor,
        setChartState = _React$useContext2[1];

    var onHover = React.useCallback(function (datum) {
      return setChartState(function (state) {
        return _objectSpread2({}, state, {
          focused: datum
        });
      });
    }, [setChartState]);
    var needsVoronoi = onFocus || onClick || tooltip || primaryCursor || secondaryCursor;
    return React.useMemo(function () {
      // Don't render until we have all dependencies
      if (!stackData || !primaryAxes.length || !secondaryAxes.length || !width || !height || !needsVoronoi) {
        return null;
      }

      var extent = [[0, 0], [gridWidth, gridHeight]]; // if (type === 'pie') {
      //   const primaryAxis = primaryAxes[0]
      //   return (
      //     <VoronoiElement
      //       style={{
      //         transform: Utils.translate(primaryAxis.width /
      //           2, primaryAxis.height / 2)
      //       }}
      //     >
      //       {stackData.map(series => (
      //         <React.Fragment key={series.index}>
      //           {series.datums.map((datum, i) => {
      //             const arc = makeArc()
      //               .startAngle(datum.arcData.startAngle)
      //               .endAngle(datum.arcData.endAngle)
      //               .padAngle(0)
      //               .padRadius(0)
      //               .innerRadius(
      //                 !series.index
      //                   ? 0
      //                   : datum.arcData.innerRadius -
      //                       datum.arcData.seriesPaddingRadius / 2
      //               )
      //               .outerRadius(
      //                 series.index === stackData.length - 1
      //                   ? Math.max(primaryAxis.width, primaryAxis.height)
      //                   : datum.arcData.outerRadius +
      //                       datum.arcData.seriesPaddingRadius / 2
      //               )
      //               .cornerRadius(0)
      //             return (
      //               <Path
      //                 key={i}
      //                 d={arc()}
      //                 className='action-voronoi'
      //                 onMouseEnter={() => onHover([datum])}
      //                 style={{
      //                   fill: 'rgba(0,0,0,.2)',
      //                   stroke: 'rgba(255,255,255,.5)',
      //                   opacity: showVoronoi ? 1 : 0
      //                 }}
      //               />
      //             )
      //           })}
      //         </React.Fragment>
      //       ))}
      //     </VoronoiElement>
      //   )
      // }

      var vor;
      var polygons = null;
      var voronoiData = [];
      stackData.forEach(function (series) {
        series.datums.filter(function (d) {
          return d.defined;
        }).forEach(function (datum) {
          datum.boundingPoints.forEach(function (boundingPoint) {
            if (typeof datum.x !== 'number' || typeof datum.y !== 'number' || Number.isNaN(datum.y) || Number.isNaN(datum.x)) {
              return;
            }

            voronoiData.push({
              x: boundingPoint.x,
              y: boundingPoint.y,
              datum: datum
            });
          });
        });
      });
      vor = Y().x(function (d) {
        return d.x;
      }).y(function (d) {
        return d.y;
      }).extent(extent)(voronoiData);
      polygons = vor.polygons();
      return /*#__PURE__*/React.createElement(VoronoiElement, null, polygons.map(function (points, i) {
        var path = lineFn(points);
        return /*#__PURE__*/React.createElement(Path, {
          key: i,
          d: path,
          className: "action-voronoi",
          onMouseEnter: function onMouseEnter(e) {
            return onHover(points.data.datum);
          },
          onMouseLeave: function onMouseLeave(e) {
            return onHover(null);
          },
          style: {
            fill: 'rgba(0,0,0,.2)',
            stroke: 'rgba(255,255,255,.5)',
            opacity: showVoronoi ? 1 : 0
          }
        });
      }));
    }, [gridHeight, gridWidth, height, onHover, primaryAxes.length, secondaryAxes.length, showVoronoi, stackData, width]);
  }

  var defaultStyle$2 = {
    strokeWidth: 1,
    fill: "transparent",
    opacity: 1
  };

  var Line = /*#__PURE__*/function (_React$Component) {
    _inherits(Line, _React$Component);

    var _super = _createSuper(Line);

    function Line() {
      _classCallCheck(this, Line);

      return _super.apply(this, arguments);
    }

    _createClass(Line, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            style = _this$props.style,
            rest = _objectWithoutProperties(_this$props, ["style"]);

        var resolvedStyle = _objectSpread2({}, defaultStyle$2, {}, style);

        return /*#__PURE__*/React.createElement("line", _extends({}, rest, {
          style: resolvedStyle
        }));
      }
    }]);

    return Line;
  }(React.Component);

  var defaultStyle$3 = {
    fontFamily: "Helvetica",
    fontSize: 10,
    opacity: 1
  };
  function Text(_ref) {
    var style = _ref.style,
        _ref$opacity = _ref.opacity,
        rest = _objectWithoutProperties(_ref, ["style", "opacity"]);

    var resolvedStyle = _objectSpread2({}, defaultStyle$3, {}, style);

    return /*#__PURE__*/React.createElement("text", _extends({}, rest, {
      style: resolvedStyle
    }));
  }

  var Group = React.forwardRef(function Group(props, ref) {
    return /*#__PURE__*/React.createElement("g", _extends({}, props, {
      ref: ref
    }));
  });

  var positionTop = "top";
  var positionRight = "right";
  var positionBottom = "bottom";
  var positionLeft = "left";
  var groupingSingle = "single";
  var groupingSeries = "series";
  var groupingPrimary = "primary";
  var groupingSecondary = "secondary";
  var alignAuto = "auto";
  var alignRight = "right";
  var alignTopRight = "topRight";
  var alignBottomRight = "bottomRight";
  var alignLeft = "left";
  var alignTopLeft = "topLeft";
  var alignBottomLeft = "bottomLeft";
  var alignTop = "top";
  var alignBottom = "bottom";
  var axisTypeOrdinal = "ordinal";
  var axisTypeTime = "time";
  var axisTypeUtc = "utc";
  var axisTypeLinear = "linear";
  var axisTypeLog = "log";
  var anchorPointer = "pointer";
  var anchorClosest = "closest";
  var anchorCenter = "center";
  var anchorTop = "top";
  var anchorBottom = "bottom";
  var anchorLeft = "left";
  var anchorRight = "right";
  var anchorGridTop = "gridTop";
  var anchorGridBottom = "gridBottom";
  var anchorGridLeft = "gridLeft";
  var anchorGridRight = "gridRight";
  var focusAuto = "auto";
  var focusClosest = "closest";
  var focusElement = "element";

  var defaultStyles = {
    line: {
      strokeWidth: '1',
      fill: 'transparent'
    },
    tick: {
      fontSize: 10,
      fontFamily: 'sans-serif'
    }
  };

  var radiansToDegrees = function radiansToDegrees(r) {
    return r * (180 / Math.PI);
  };

  function AxisLinear(_ref) {
    var id = _ref.id,
        type = _ref.type,
        position = _ref.position,
        tickSizeInner = _ref.tickSizeInner,
        tickSizeOuter = _ref.tickSizeOuter,
        show = _ref.show,
        showGrid = _ref.showGrid,
        showTicks = _ref.showTicks,
        styles = _ref.styles,
        maxLabelRotation = _ref.maxLabelRotation,
        labelRotationStep = _ref.labelRotationStep,
        tickPadding = _ref.tickPadding,
        ticks = _ref.ticks,
        tickCount = _ref.tickCount,
        minTickCount = _ref.minTickCount,
        maxTickCount = _ref.maxTickCount,
        scale = _ref.scale,
        scaleMax = _ref.max,
        transform = _ref.transform,
        vertical = _ref.vertical,
        format = _ref.format,
        _ref$range = _slicedToArray(_ref.range, 2),
        range0 = _ref$range[0],
        range1 = _ref$range[1],
        directionMultiplier = _ref.directionMultiplier,
        tickOffset = _ref.tickOffset,
        gridOffset = _ref.gridOffset,
        spacing = _ref.spacing;

    var _React$useState = React.useState(0),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        rotation = _React$useState2[0],
        setRotation = _React$useState2[1];

    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 2),
        _React$useContext2$ = _React$useContext2[0],
        gridWidth = _React$useContext2$.gridWidth,
        gridHeight = _React$useContext2$.gridHeight,
        dark = _React$useContext2$.dark,
        axisDimensions = _React$useContext2$.axisDimensions,
        setChartState = _React$useContext2[1];

    var elRef = React.useRef();
    var visibleLabelStepRef = React.useRef();
    var measureDimensions = React.useCallback(function () {
      if (!elRef.current) {
        if (axisDimensions[position] && axisDimensions[position][id]) {
          // If the entire axis is hidden, then we need to remove the axis dimensions
          setChartState(function (state) {
            var newAxes = state.axisDimensions[position] || {};
            delete newAxes[id];
            return _objectSpread2({}, state, {
              axisDimensions: _objectSpread2({}, state.axisDimensions, _defineProperty({}, position, newAxes))
            });
          });
        }

        return;
      }

      var labelDims = Array.apply(void 0, _toConsumableArray(elRef.current.querySelectorAll('.tickLabel'))).map(function (el) {
        var rect = el.getBoundingClientRect();
        return {
          width: rect.width,
          height: rect.height
        };
      });
      var tickSpace = !vertical ? gridWidth : gridHeight;
      var calculatedTickCount = tickCount;
      var width = 0;
      var height = 0;
      var top = 0;
      var bottom = 0;
      var left = 0;
      var right = 0;
      var smallestTickGap = 100000; // This is just a ridiculously large tick spacing that would never happen (hopefully)
      // First find the dimensions of each tick

      var tickDims = Array.apply(void 0, _toConsumableArray(elRef.current.querySelectorAll('.tick'))).map(function (el) {
        return el.getBoundingClientRect();
      }); // Then, determine the smallest gap in ticks on the axis

      tickDims.reduce(function (prev, current) {
        if (prev) {
          var gap = vertical ? current.top - prev.top : current.left - prev.left;
          smallestTickGap = gap < smallestTickGap ? gap : smallestTickGap;
        }

        return current;
      }, false);
      var firstLabelDim = labelDims[0] || {
        width: 0,
        height: 0
      };
      var lastLabelDim = labelDims[labelDims.length - 1] || {
        width: 0,
        height: 0
      }; // Then determine the largest label

      var largestLabel = _objectSpread2({}, firstLabelDim, {
        _overflow: 0
      }); // Determine the largest label on the axis


      labelDims.forEach(function (labelDim) {
        labelDim._overflow = !vertical ? labelDim.width : labelDim.height - smallestTickGap;

        if (labelDim._overflow > 0 && labelDim._overflow > largestLabel._overflow) {
          largestLabel = labelDim;
        }
      });
      var largestLabelSize = !vertical ? largestLabel.width : largestLabel.height; // We need to detect auto tick mode

      if ((vertical || type !== 'ordinal') && tickCount === 'auto') {
        // if it's on, determine how many ticks we could display if they were all flat
        // How many ticks can we fit in the available axis space?
        calculatedTickCount = Math.max(minTickCount, Math.min(Math.floor((tickSpace + largestLabelSize - tickPadding) / (largestLabelSize + tickPadding * 2)), maxTickCount));
      } else if (!vertical) {
        // Otherwise, if it's horizontal, then we need to determine axis rotation
        // This is the raw mathematical rotation, using acosign and radians
        // (some tricky stuff I found on some geomoetry forum. Can't remember where though)
        var newRotation = Math.min(Math.max(Math.abs(radiansToDegrees(Math.acos(smallestTickGap / (largestLabel.width + tickPadding)))), 0), maxLabelRotation); // Make sure the rotation isn't NaN

        newRotation = Number.isNaN(newRotation) ? 0 : newRotation; // Round the rotation to the nearest rotationStep

        newRotation = Math.ceil(Math.ceil(newRotation / labelRotationStep) * labelRotationStep);

        if (newRotation === 0 || newRotation === maxLabelRotation || Math.abs(newRotation) - Math.abs(rotation) > 5) {
          setRotation(function () {
            return position === 'top' ? -newRotation : newRotation;
          });
        }
      }

      var newVisibleLabelStep = Math.ceil(tickPadding / smallestTickGap);

      if (visibleLabelStepRef.current !== newVisibleLabelStep) {
        visibleLabelStepRef.current = newVisibleLabelStep;
      }

      if (!vertical) {
        // Add width overflow from the first and last ticks
        // const leftWidth = firstLabelDim.width
        // const rightWidth = lastLabelDim.width
        // if (rotation) {
        //   right = tickPadding
        //   left = Math.abs(Math.ceil(Math.cos(rotation) * leftWidth)) - barSize / 2
        // } else {
        //   left = Math.ceil(leftWidth / 2)
        //   right = Math.ceil(rightWidth / 2)
        // }
        height = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
        tickPadding + // Add tick padding
        // Add the height of the largest label
        Math.max.apply(Math, [0].concat(_toConsumableArray(labelDims.map(function (d) {
          return Math.ceil(d.height);
        }))));
      } else {
        // Add height overflow from the first and last ticks
        top = Math.ceil(firstLabelDim.height / 2);
        bottom = Math.ceil(lastLabelDim.height / 2);
        width = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
        tickPadding + // Add tick padding
        // Add the width of the largest label
        Math.max.apply(Math, [0].concat(_toConsumableArray(labelDims.map(function (d) {
          return Math.ceil(d.width);
        }))));
      }

      var newDimensions = {
        width: width,
        height: height,
        top: top,
        bottom: bottom,
        left: left,
        right: right,
        tickCount: calculatedTickCount
      }; // Only update the axisDimensions if something has changed

      if (!axisDimensions || !axisDimensions[position] || !axisDimensions[position][id] || Object.keys(newDimensions).some(function (key) {
        return newDimensions[key] !== axisDimensions[position][id][key];
      })) {
        setChartState(function (state) {
          return _objectSpread2({}, state, {
            axisDimensions: _objectSpread2({}, state.axisDimensions, _defineProperty({}, position, _objectSpread2({}, state.axisDimensions[position] || {}, _defineProperty({}, id, newDimensions))))
          });
        });
      }
    }, [axisDimensions, gridHeight, gridWidth, id, labelRotationStep, maxLabelRotation, maxTickCount, minTickCount, position, rotation, setChartState, tickCount, tickPadding, tickSizeInner, tickSizeOuter, type, vertical]);
    var previousRotation = usePrevious(rotation); // Measure after if needed

    React.useLayoutEffect(function () {
      if (previousRotation === rotation) {
        measureDimensions();
      }
    }, [axisDimensions, id, measureDimensions, position, previousRotation, rotation]); // Measure after if needed

    React.useEffect(function () {
      if (previousRotation !== rotation) {
        measureDimensions();
      }
    }, [axisDimensions, id, measureDimensions, position, previousRotation, rotation]); // Not ready? Render null

    if (!show) {
      return null;
    }

    var axisPath;

    if (vertical) {
      if (position === positionLeft) {
        axisPath = "\n        M ".concat(-tickSizeOuter, ", ").concat(range0, "\n        H 0\n        V ").concat(range1, "\n        H ").concat(-tickSizeOuter, "\n      ");
      } else {
        axisPath = "\n        M ".concat(tickSizeOuter, ", ").concat(range0, "\n        H 0\n        V ").concat(range1, "\n        H ").concat(tickSizeOuter, "\n      ");
      }
    } else if (position === positionBottom) {
      axisPath = "\n        M 0, ".concat(tickSizeOuter, "\n        V 0\n        H ").concat(range1, "\n        V ").concat(tickSizeOuter, "\n      ");
    } else {
      axisPath = "\n        M 0, ".concat(-tickSizeOuter, "\n        V 0\n        H ").concat(range1, "\n        V ").concat(-tickSizeOuter, "\n              ");
    }

    var showGridLine;

    if (typeof showGrid === 'boolean') {
      showGridLine = showGrid;
    } else if (type === axisTypeOrdinal) {
      showGridLine = false;
    } else {
      showGridLine = true;
    } // Combine default styles with style props


    var axisStyles = _objectSpread2({}, defaultStyles, {}, styles);

    return /*#__PURE__*/React.createElement(Group, {
      ref: elRef,
      className: "Axis",
      style: {
        pointerEvents: 'none',
        transform: position === positionRight ? Utils.translateX(gridWidth) : position === positionBottom ? Utils.translateY(gridHeight) : undefined
      }
    }, /*#__PURE__*/React.createElement(Path, {
      className: "domain",
      d: axisPath,
      style: _objectSpread2({
        stroke: dark ? 'rgba(255,255,255, .1)' : 'rgba(0,0,0, .1)'
      }, axisStyles.line)
    }), /*#__PURE__*/React.createElement(Group, {
      className: "ticks",
      style: {}
    }, ticks.map(function (tick, i) {
      return /*#__PURE__*/React.createElement(Group, {
        key: [String(tick), i].join('_'),
        className: "tick",
        style: {
          transform: transform(scale(tick) || 0)
        }
      }, showGridLine && /*#__PURE__*/React.createElement(Line, {
        className: "gridLine",
        x1: vertical ? 0 : gridOffset,
        x2: vertical ? scaleMax : gridOffset,
        y1: vertical ? gridOffset : 0,
        y2: vertical ? gridOffset : scaleMax,
        style: _objectSpread2({
          stroke: dark ? 'rgba(255,255,255, .1)' : 'rgba(0,0,0, .1)',
          strokeWidth: 1
        }, axisStyles.line)
      }), showTicks ? /*#__PURE__*/React.createElement("g", {
        className: "labelGroup"
      }, /*#__PURE__*/React.createElement(Line, {
        className: "tickline",
        x1: vertical ? 0 : tickOffset,
        x2: vertical ? directionMultiplier * tickSizeInner : tickOffset,
        y1: vertical ? tickOffset : 0,
        y2: vertical ? tickOffset : directionMultiplier * tickSizeInner,
        style: _objectSpread2({
          stroke: dark ? 'rgba(255,255,255, .1)' : 'rgba(0,0,0, .1)',
          strokeWidth: 1
        }, axisStyles.line)
      }), /*#__PURE__*/React.createElement(Text, {
        className: "tickLabel",
        style: _objectSpread2({
          fill: dark ? 'white' : 'black'
        }, axisStyles.tick, {
          transform: "".concat(Utils.translate(vertical ? directionMultiplier * spacing : tickOffset, vertical ? tickOffset : directionMultiplier * spacing), " rotate(").concat(-rotation, "deg)")
        }),
        dominantBaseline: rotation ? 'central' : position === positionBottom ? 'hanging' : position === positionTop ? 'alphabetic' : 'central',
        textAnchor: rotation ? 'end' : position === positionRight ? 'start' : position === positionLeft ? 'end' : 'middle'
      }, format(tick, i))) : null);
    })));
  }

  function Axis(props) {
    return /*#__PURE__*/React.createElement(AxisLinear, props);
  }

  var triangleSize = 7;

  var getBackgroundColor = function getBackgroundColor(dark) {
    return dark ? "rgba(255,255,255,.9)" : "rgba(0, 26, 39, 0.9)";
  };

  function Tooltip() {
    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 1),
        chartState = _React$useContext2[0];

    var primaryAxes = chartState.primaryAxes,
        secondaryAxes = chartState.secondaryAxes,
        gridX = chartState.gridX,
        gridY = chartState.gridY,
        gridWidth = chartState.gridWidth,
        gridHeight = chartState.gridHeight,
        dark = chartState.dark,
        focused = chartState.focused,
        latestFocused = chartState.latestFocused,
        getDatumStyle = chartState.getDatumStyle,
        tooltip = chartState.tooltip;
    var elRef = React.useRef();
    var tooltipElRef = React.useRef();
    var previousShowRef = React.useRef();

    var _ref = tooltip || {},
        align = _ref.align,
        alignPriority = _ref.alignPriority,
        padding = _ref.padding,
        tooltipArrowPadding = _ref.tooltipArrowPadding,
        arrowPosition = _ref.arrowPosition,
        render = _ref.render,
        anchor = _ref.anchor,
        show = _ref.show;

    var _React$useState = React.useState(align || "auto"),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        finalAlign = _React$useState2[0],
        setFinalAlign = _React$useState2[1];

    React.useEffect(function () {
      previousShowRef.current = show;
    }, [show]);
    React.useLayoutEffect(function () {
      if (align !== "auto" || !elRef.current || !show || !anchor) {
        return;
      }

      var space = {
        left: Infinity,
        top: Infinity,
        right: Infinity,
        bottom: Infinity
      };
      var container = elRef.current;
      var gridDims = container.getBoundingClientRect();
      var tooltipDims = tooltipElRef.current.getBoundingClientRect();

      while (container !== document.body) {
        container = container.parentElement;

        var _window$getComputedSt = window.getComputedStyle(container),
            overflowX = _window$getComputedSt.overflowX,
            overflowY = _window$getComputedSt.overflowY;

        if (container === document.body || [overflowX, overflowY].find(function (d) {
          return ["auto", "hidden"].includes(d);
        })) {
          var containerDims = container.getBoundingClientRect();
          var left = gridDims.left - containerDims.left + anchor.x;
          var top = gridDims.top - containerDims.top + anchor.y;
          var right = containerDims.width - left;
          var bottom = containerDims.height - top;
          space.left = Math.min(space.left, left);
          space.top = Math.min(space.top, top);
          space.right = Math.min(space.right, right);
          space.bottom = Math.min(space.bottom, bottom);
        }
      }

      var resolvedAlign = null;
      alignPriority.forEach(function (priority) {
        if (resolvedAlign) {
          return;
        }

        var fits = {
          left: space.left - tooltipArrowPadding - padding - anchor.horizontalPadding > tooltipDims.width,
          right: space.right - tooltipArrowPadding - padding - anchor.horizontalPadding > tooltipDims.width,
          top: space.top - tooltipArrowPadding - padding - anchor.verticalPadding > tooltipDims.height && space.left > tooltipDims.width / 2,
          bottom: space.bottom - tooltipArrowPadding - padding - anchor.verticalPadding > tooltipDims.height,
          centeredFromLeft: space.left > tooltipDims.width / 2,
          centeredFromRight: space.right > tooltipDims.width / 2,
          centeredFromTop: space.top > tooltipDims.height / 2,
          centeredFromBottom: space.bottom > tooltipDims.height / 2
        };

        if (priority === "left") {
          if (fits.left && fits.centeredFromTop && fits.centeredFromBottom) {
            resolvedAlign = priority;
          }
        } else if (priority === "right") {
          if (fits.right && fits.centeredFromTop && fits.centeredFromBottom) {
            resolvedAlign = priority;
          }
        } else if (priority === "top") {
          if (fits.top && fits.centeredFromLeft && fits.centeredFromRight) {
            resolvedAlign = priority;
          }
        } else if (priority === "bottom") {
          if (fits.bottom && fits.centeredFromLeft && fits.centeredFromRight) {
            resolvedAlign = priority;
          }
        } else if (priority === "topLeft") {
          if (fits.top && fits.left) {
            resolvedAlign = priority;
          }
        } else if (priority === "topRight") {
          if (fits.top && fits.right) {
            resolvedAlign = priority;
          }
        } else if (priority === "bottomLeft") {
          if (fits.bottom && fits.left) {
            resolvedAlign = priority;
          }
        } else if (priority === "bottomRight") {
          if (fits.bottom && fits.right) {
            resolvedAlign = priority;
          }
        }
      });

      if (resolvedAlign !== finalAlign) {
        setFinalAlign(resolvedAlign);
      }
    }, [align, alignPriority, anchor, finalAlign, padding, show, tooltipArrowPadding]);

    if (!tooltip) {
      return null;
    }

    var resolvedFocused = focused || latestFocused;
    var alignX = 0;
    var alignY = -50;
    var triangleStyles = {};
    var backgroundColor = getBackgroundColor(dark);
    var resolvedArrowPosition = arrowPosition;

    if (finalAlign === "top") {
      alignX = -50;
      alignY = -100;
    } else if (finalAlign === "topRight") {
      alignX = 0;
      alignY = -100;
    } else if (finalAlign === "right") {
      alignX = 0;
      alignY = -50;
    } else if (finalAlign === "bottomRight") {
      alignX = 0;
      alignY = 0;
    } else if (finalAlign === "bottom") {
      alignX = -50;
      alignY = 0;
    } else if (finalAlign === "bottomLeft") {
      alignX = -100;
      alignY = 0;
    } else if (finalAlign === "left") {
      alignX = -100;
      alignY = -50;
    } else if (finalAlign === "topLeft") {
      alignX = -100;
      alignY = -100;
    } else if (finalAlign === "center") {
      alignX = -50;
      alignY = -50;
    }

    if (!resolvedArrowPosition) {
      if (finalAlign === "left") {
        resolvedArrowPosition = "right";
      } else if (finalAlign === "right") {
        resolvedArrowPosition = "left";
      } else if (finalAlign === "top") {
        resolvedArrowPosition = "bottom";
      } else if (finalAlign === "bottom") {
        resolvedArrowPosition = "top";
      } else if (finalAlign === "topRight") {
        resolvedArrowPosition = "bottomLeft";
      } else if (finalAlign === "bottomRight") {
        resolvedArrowPosition = "topLeft";
      } else if (finalAlign === "topLeft") {
        resolvedArrowPosition = "bottomRight";
      } else if (finalAlign === "bottomLeft") {
        resolvedArrowPosition = "topRight";
      }
    }

    if (resolvedArrowPosition === "bottom") {
      triangleStyles = {
        top: "100%",
        left: "50%",
        transform: "translate3d(-50%, 0%, 0)",
        borderLeft: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderRight: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderTop: "".concat(triangleSize, "px solid ").concat(backgroundColor)
      };
    } else if (resolvedArrowPosition === "top") {
      triangleStyles = {
        top: "0%",
        left: "50%",
        transform: "translate3d(-50%, -100%, 0)",
        borderLeft: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderRight: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderBottom: "".concat(triangleSize, "px solid ").concat(backgroundColor)
      };
    } else if (resolvedArrowPosition === "right") {
      triangleStyles = {
        top: "50%",
        left: "100%",
        transform: "translate3d(0%, -50%, 0)",
        borderTop: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderBottom: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderLeft: "".concat(triangleSize, "px solid ").concat(backgroundColor)
      };
    } else if (resolvedArrowPosition === "left") {
      triangleStyles = {
        top: "50%",
        left: "0%",
        transform: "translate3d(-100%, -50%, 0)",
        borderTop: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderBottom: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderRight: "".concat(triangleSize, "px solid ").concat(backgroundColor)
      };
    } else if (resolvedArrowPosition === "topRight") {
      triangleStyles = {
        top: "0%",
        left: "100%",
        transform: "translate3d(-50%, -50%, 0) rotate(-45deg)",
        borderTop: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderBottom: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderLeft: "".concat(triangleSize * 2, "px solid ").concat(backgroundColor)
      };
    } else if (resolvedArrowPosition === "bottomRight") {
      triangleStyles = {
        top: "100%",
        left: "100%",
        transform: "translate3d(-50%, -50%, 0) rotate(45deg)",
        borderTop: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderBottom: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderLeft: "".concat(triangleSize * 2, "px solid ").concat(backgroundColor)
      };
    } else if (resolvedArrowPosition === "topLeft") {
      triangleStyles = {
        top: "0%",
        left: "0%",
        transform: "translate3d(-50%, -50%, 0) rotate(45deg)",
        borderTop: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderBottom: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderRight: "".concat(triangleSize * 2, "px solid ").concat(backgroundColor)
      };
    } else if (resolvedArrowPosition === "bottomLeft") {
      triangleStyles = {
        top: "100%",
        left: "0%",
        transform: "translate3d(-50%, -50%, 0) rotate(-45deg)",
        borderTop: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderBottom: "".concat(triangleSize * 0.8, "px solid transparent"),
        borderRight: "".concat(triangleSize * 2, "px solid ").concat(backgroundColor)
      };
    } else {
      triangleStyles = {
        opacity: 0
      };
    }

    var primaryAxis = Utils.getAxisByAxisID(primaryAxes, resolvedFocused ? resolvedFocused.series.primaryAxisID : null);
    var secondaryAxis = Utils.getAxisByAxisID(secondaryAxes, resolvedFocused ? resolvedFocused.series.secondaryAxisID : null);
    var resolvedHorizontalPadding = padding + anchor.horizontalPadding;
    var resolvedVerticalPadding = padding + anchor.verticalPadding;

    var renderProps = _objectSpread2({}, chartState, {}, chartState.tooltip, {
      datum: resolvedFocused,
      getStyle: function getStyle(datum) {
        return datum.getStatusStyle(resolvedFocused, getDatumStyle);
      },
      primaryAxis: primaryAxis,
      secondaryAxis: secondaryAxis
    });

    var renderedChildren = React.createElement(render, renderProps);
    var animateCoords;

    if (previousShowRef.current === show) {
      animateCoords = true;
    }

    return /*#__PURE__*/React.createElement("div", {
      className: "tooltip-wrap",
      style: {
        pointerEvents: "none",
        position: "absolute",
        left: "".concat(gridX, "px"),
        top: "".concat(gridY, "px"),
        width: "".concat(gridWidth, "px"),
        height: "".concat(gridHeight, "px"),
        opacity: show ? 1 : 0,
        transition: "all .3s ease"
      },
      ref: function ref(el) {
        elRef.current = el;
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        transform: Utils.translate(anchor.x, anchor.y),
        transition: animateCoords ? "all .2s ease" : "opacity .2s ease"
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        transform: "translate3d(".concat(alignX, "%, ").concat(alignY, "%, 0)"),
        padding: "".concat(tooltipArrowPadding + resolvedVerticalPadding, "px ").concat(tooltipArrowPadding + resolvedHorizontalPadding, "px"),
        width: "auto",
        transition: "all .2s ease"
      }
    }, /*#__PURE__*/React.createElement("div", {
      ref: function ref(el) {
        tooltipElRef.current = el;
      },
      style: {
        fontSize: "12px",
        padding: "5px",
        background: getBackgroundColor(dark),
        color: dark ? "black" : "white",
        borderRadius: "3px",
        position: "relative"
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: _objectSpread2({
        position: "absolute",
        width: 0,
        height: 0
      }, triangleStyles, {
        transition: animateCoords ? "all .2s ease" : "none"
      })
    }), renderedChildren))));
  }

  var getLineBackgroundColor = function getLineBackgroundColor(dark) {
    return dark ? "rgba(255,255,255,.3)" : "rgba(0, 26, 39, 0.3)";
  };

  var getBackgroundColor$1 = function getBackgroundColor(dark) {
    return dark ? "rgba(255,255,255,.9)" : "rgba(0, 26, 39, 0.9)";
  };

  function Cursor(_ref) {
    var primary = _ref.primary;

    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 1),
        _React$useContext2$ = _React$useContext2[0],
        primaryCursor = _React$useContext2$.primaryCursor,
        secondaryCursor = _React$useContext2$.secondaryCursor,
        focused = _React$useContext2$.focused,
        latestFocused = _React$useContext2$.latestFocused,
        gridX = _React$useContext2$.gridX,
        gridY = _React$useContext2$.gridY,
        dark = _React$useContext2$.dark;

    var resolvedFocused = focused || latestFocused;
    var cursor = primary ? primaryCursor : secondaryCursor;

    var _ref2 = cursor || {},
        showLine = _ref2.showLine,
        showLabel = _ref2.showLabel,
        resolvedValue = _ref2.resolvedValue,
        snap = _ref2.snap,
        render = _ref2.render,
        axis = _ref2.axis,
        siblingAxis = _ref2.siblingAxis,
        resolvedShow = _ref2.resolvedShow;

    var latestValue = useLatest(resolvedValue, typeof resolvedValue !== "undefined");
    var previousShowRef = React.useRef();
    React.useEffect(function () {
      previousShowRef.current = resolvedShow;
    }, [resolvedShow]);

    if (!cursor) {
      return null;
    } // Should we animate?


    var animated = snap || axis.type === "ordinal"; // Get the sibling range

    var siblingRange = siblingAxis.scale.range();
    var x;
    var y;
    var x1;
    var x2;
    var y1;
    var y2;
    var alignPctX;
    var alignPctY; // Vertical alignment

    if (axis.vertical) {
      y = axis.scale(latestValue);
      x1 = siblingRange[0];
      x2 = siblingRange[1];
      y1 = y - 1;
      y2 = y + axis.cursorSize + 1;

      if (axis.position === "left") {
        alignPctX = -100;
        alignPctY = -50;
      } else {
        alignPctX = 0;
        alignPctY = -50;
      }
    } else {
      x = axis.scale(latestValue);
      x1 = x - 1;
      x2 = x + axis.cursorSize + 1;
      y1 = siblingRange[0];
      y2 = siblingRange[1];

      if (axis.position === "top") {
        alignPctX = -500;
        alignPctY = -100;
      } else {
        alignPctX = -50;
        alignPctY = 0;
      }
    }

    var renderProps = _objectSpread2({}, cursor);

    renderProps.formattedValue = String(axis.vertical ? typeof latestValue !== "undefined" ? axis.format(axis.stacked && !primary && resolvedFocused ? resolvedFocused.totalValue : latestValue) : "" : typeof latestValue !== "undefined" ? axis.format(axis.stacked && !primary && resolvedFocused ? resolvedFocused.totalValue : latestValue) : "");
    var lineStartX = Math.min(x1, x2);
    var lineStartY = Math.min(y1, y2);
    var lineEndX = Math.max(x1, x2);
    var lineEndY = Math.max(y1, y2);
    var bubbleX = axis.vertical && axis.RTL ? lineEndX : x1 + (!axis.vertical ? (x2 - x1) / 2 : 0) + (!axis.vertical ? 1 : 0);
    var bubbleY = !axis.vertical && axis.RTL ? lineStartY : y1 + (axis.vertical ? (y2 - y1) / 2 : 0) + (axis.vertical ? 1 : 0);
    var lineHeight = Math.max(lineEndY - lineStartY, 0);
    var lineWidth = Math.max(lineEndX - lineStartX, 0);
    var animateCoords;

    if (previousShowRef.current === resolvedShow) {
      animateCoords = true;
    }

    var renderedChildren = render(renderProps);
    return /*#__PURE__*/React.createElement("div", {
      style: {
        pointerEvents: "none",
        position: "absolute",
        top: 0,
        left: 0,
        transform: Utils.translate(gridX, gridY),
        opacity: resolvedShow ? 1 : 0,
        transition: "all .3s ease"
      },
      className: "Cursor"
    }, showLine ? /*#__PURE__*/React.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: Utils.translate(lineStartX, lineStartY),
        width: "".concat(lineWidth, "px"),
        height: "".concat(lineHeight, "px"),
        background: getLineBackgroundColor(dark),
        transition: animated && animateCoords ? "all .2s ease" : "opacity .2s ease"
      }
    }) : null, showLabel ? /*#__PURE__*/React.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: Utils.translate(bubbleX, bubbleY),
        transition: animated && animateCoords ? "all .2s ease" : "opacity .2s ease"
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        padding: "5px",
        fontSize: "10px",
        background: getBackgroundColor$1(dark),
        color: getBackgroundColor$1(!dark),
        borderRadius: "3px",
        position: "relative",
        transform: "translate3d(".concat(alignPctX, "%, ").concat(alignPctY, "%, 0)"),
        whiteSpace: "nowrap"
      }
    }, renderedChildren)) : null);
  }

  function Brush() {
    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 1),
        _React$useContext2$ = _React$useContext2[0],
        pointer = _React$useContext2$.pointer,
        brush = _React$useContext2$.brush,
        gridX = _React$useContext2$.gridX,
        gridY = _React$useContext2$.gridY,
        gridHeight = _React$useContext2$.gridHeight,
        dark = _React$useContext2$.dark;

    if (!brush) {
      return null;
    }

    return /*#__PURE__*/React.createElement("div", {
      className: "Brush",
      style: {
        pointerEvents: 'none',
        position: 'absolute',
        left: 0,
        top: 0,
        transform: Utils.translate(gridX, gridY),
        opacity: pointer.dragging ? Math.abs(pointer.sourceX - pointer.x) < 20 ? 0.5 : 1 : 0
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: _objectSpread2({
        position: 'absolute',
        transform: Utils.translate(Math.min(pointer.x, pointer.sourceX), 0),
        width: "".concat(Math.abs(pointer.x - pointer.sourceX), "px"),
        height: "".concat(gridHeight, "px"),
        background: dark ? 'rgba(255,255,255,.3)' : 'rgba(0, 26, 39, 0.3)'
      }, brush.style)
    }));
  }

  var ChartInner = React.forwardRef(function ChartInner(_ref, ref) {
    var className = _ref.className,
        _ref$style = _ref.style,
        style = _ref$style === void 0 ? {} : _ref$style,
        rest = _objectWithoutProperties(_ref, ["className", "style"]);

    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 1),
        chartState = _React$useContext2[0];

    var _React$useContext3 = React.useContext(ChartContext),
        _React$useContext4 = _slicedToArray(_React$useContext3, 2),
        _React$useContext4$ = _React$useContext4[0],
        width = _React$useContext4$.width,
        height = _React$useContext4$.height,
        offset = _React$useContext4$.offset,
        gridX = _React$useContext4$.gridX,
        gridY = _React$useContext4$.gridY,
        stackData = _React$useContext4$.stackData,
        primaryAxes = _React$useContext4$.primaryAxes,
        secondaryAxes = _React$useContext4$.secondaryAxes,
        renderSVG = _React$useContext4$.renderSVG,
        onClick = _React$useContext4$.onClick,
        seriesOptions = _React$useContext4$.seriesOptions,
        getSeriesOrder = _React$useContext4$.getSeriesOrder,
        focused = _React$useContext4$.focused,
        setChartState = _React$useContext4[1];

    var svgRef = React.useRef();
    React.useLayoutEffect(function () {
      if (!svgRef.current) {
        return;
      }

      var current = svgRef.current.getBoundingClientRect();

      if (current.left !== offset.left || current.top !== offset.top) {
        setChartState(function (state) {
          return _objectSpread2({}, state, {
            offset: {
              left: current.left,
              top: current.top
            }
          });
        });
      }
    });

    var _onMouseLeave = function onMouseLeave(e) {
      setChartState(function (state) {
        return _objectSpread2({}, state, {
          focused: null
        });
      });
      setChartState(function (state) {
        return _objectSpread2({}, state, {
          pointer: _objectSpread2({}, state.pointer, {
            active: false
          })
        });
      });
    };

    var rafRef = React.useRef();

    var _onMouseMove = function onMouseMove(e) {
      if (rafRef.current) {
        Raf.cancel(rafRef.current);
      }

      rafRef.current = Raf(function () {
        rafRef.current = null;
        var clientX = e.clientX,
            clientY = e.clientY;
        setChartState(function (state) {
          var x = clientX - offset.left - gridX;
          var y = clientY - offset.top - gridY;

          var pointer = _objectSpread2({}, state.pointer, {
            active: true,
            x: x,
            y: y,
            dragging: state.pointer && state.pointer.down
          });

          return _objectSpread2({}, state, {
            pointer: pointer
          });
        });
      });
    };

    var onMouseUp = function onMouseUp() {
      document.removeEventListener("mouseup", onMouseUp);
      document.removeEventListener("mousemove", _onMouseMove);
      setChartState(function (state) {
        return _objectSpread2({}, state, {
          pointer: _objectSpread2({}, state.pointer, {
            down: false,
            dragging: false,
            released: {
              x: state.pointer.x,
              y: state.pointer.y
            }
          })
        });
      });
    };

    var _onMouseDown = function onMouseDown() {
      document.addEventListener("mouseup", onMouseUp);
      document.addEventListener("mousemove", _onMouseMove);
      setChartState(function (state) {
        return _objectSpread2({}, state, {
          pointer: _objectSpread2({}, state.pointer, {
            sourceX: state.pointer.x,
            sourceY: state.pointer.y,
            down: true
          })
        });
      });
    }; // Reverse the stack order for proper z-indexing


    var reversedStackData = _toConsumableArray(stackData).reverse();

    var orderedStackData = getSeriesOrder(reversedStackData);
    var focusedSeriesIndex = focused ? orderedStackData.findIndex(function (series) {
      return series.id === focused.series.id;
    }) : -1; // Bring focused series to the front

    var focusOrderedStackData = focused ? [].concat(_toConsumableArray(orderedStackData.slice(0, focusedSeriesIndex)), _toConsumableArray(orderedStackData.slice(focusedSeriesIndex + 1)), [orderedStackData[focusedSeriesIndex]]) : orderedStackData;
    var stacks = focusOrderedStackData.map(function (stack) {
      return /*#__PURE__*/React.createElement(stack.Component, _extends({
        key: stack.id
      }, seriesOptions[stack.index], {
        series: stack,
        stackData: stackData
      }));
    });
    return /*#__PURE__*/React.createElement("div", _extends({
      ref: ref
    }, rest, {
      className: "ReactChart ".concat(className || ""),
      style: _objectSpread2({
        width: width,
        height: height,
        position: "relative"
      }, style)
    }), /*#__PURE__*/React.createElement("svg", {
      ref: svgRef,
      style: {
        width: width,
        height: height,
        overflow: "hidden"
      },
      onMouseEnter: function onMouseEnter(e) {
        return e.persist() || _onMouseMove(e);
      },
      onMouseMove: function onMouseMove(e) {
        return e.persist() || _onMouseMove(e);
      },
      onMouseLeave: function onMouseLeave(e) {
        return e.persist() || _onMouseLeave();
      },
      onMouseDown: function onMouseDown(e) {
        return e.persist() || _onMouseDown();
      },
      onClick: onClick
    }, /*#__PURE__*/React.createElement("g", {
      style: {
        transform: Utils.translate(gridX, gridY)
      }
    }, /*#__PURE__*/React.createElement(Rectangle // To ensure the pointer always has something to hit
    , {
      x1: -gridX,
      x2: width - gridX,
      y1: -gridY,
      y2: height - gridY,
      style: {
        opacity: 0
      }
    }), /*#__PURE__*/React.createElement(Voronoi, null), /*#__PURE__*/React.createElement("g", {
      className: "axes"
    }, [].concat(_toConsumableArray(primaryAxes), _toConsumableArray(secondaryAxes)).map(function (axis) {
      return /*#__PURE__*/React.createElement(Axis, _extends({
        key: axis.id
      }, axis));
    })), /*#__PURE__*/React.createElement("g", {
      className: "Series",
      style: {
        pointerEvents: "none"
      }
    }, stacks)), renderSVG ? renderSVG({
      chartState: chartState,
      setChartState: setChartState
    }) : null), /*#__PURE__*/React.createElement(Cursor, {
      primary: true
    }), /*#__PURE__*/React.createElement(Cursor, null), /*#__PURE__*/React.createElement(Brush, null), /*#__PURE__*/React.createElement(Tooltip, null));
  });

  var useMaterializeData = (function (_ref) {
    var data = _ref.data,
        getSeriesID = _ref.getSeriesID,
        getLabel = _ref.getLabel,
        getPrimaryAxisID = _ref.getPrimaryAxisID,
        getSecondaryAxisID = _ref.getSecondaryAxisID,
        getDatums = _ref.getDatums,
        getPrimary = _ref.getPrimary,
        getSecondary = _ref.getSecondary,
        getR = _ref.getR;
    return React.useMemo(function () {
      var materializedData = []; // First access the data, and provide it to the context

      for (var seriesIndex = 0; seriesIndex < data.length; seriesIndex++) {
        var originalSeries = data[seriesIndex];
        var seriesID = getSeriesID(originalSeries, seriesIndex, data);
        var seriesLabel = getLabel(originalSeries, seriesIndex, data);
        var primaryAxisID = getPrimaryAxisID(originalSeries, seriesIndex, data);
        var secondaryAxisID = getSecondaryAxisID(originalSeries, seriesIndex, data);
        var originalDatums = getDatums(originalSeries, seriesIndex, data);
        var datums = [];

        for (var datumIndex = 0; datumIndex < originalDatums.length; datumIndex++) {
          var originalDatum = originalDatums[datumIndex];
          datums[datumIndex] = {
            originalSeries: originalSeries,
            seriesIndex: seriesIndex,
            seriesID: seriesID,
            seriesLabel: seriesLabel,
            index: datumIndex,
            originalDatum: originalDatum,
            primary: getPrimary(originalDatum, datumIndex, originalSeries, seriesIndex, data),
            secondary: getSecondary(originalDatum, datumIndex, originalSeries, seriesIndex, data),
            r: getR(originalDatum, datumIndex, originalSeries, seriesIndex, data)
          };
        }

        materializedData[seriesIndex] = {
          originalSeries: originalSeries,
          index: seriesIndex,
          id: seriesID,
          label: seriesLabel,
          primaryAxisID: primaryAxisID,
          secondaryAxisID: secondaryAxisID,
          datums: datums
        };
      }

      return materializedData;
    }, [data, getDatums, getLabel, getPrimary, getPrimaryAxisID, getR, getSecondary, getSecondaryAxisID, getSeriesID]);
  });

  function usePropsMemo(fn) {
    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var watchRef = React.useRef({
      style: {},
      props: {}
    });
    var valueRef = React.useRef();

    var _obj$style = obj.style,
        style = _obj$style === void 0 ? {} : _obj$style,
        props = _objectWithoutProperties(obj, ["style"]);

    if (Utils.shallowDiff(watchRef.current.style, style) || Utils.shallowDiff(watchRef.current.props, props)) {
      watchRef.current = obj;
      valueRef.current = fn();
    }

    return valueRef.current;
  }

  function useSeriesStyle(series) {
    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 1),
        _React$useContext2$ = _React$useContext2[0],
        focused = _React$useContext2$.focused,
        getSeriesStyle = _React$useContext2$.getSeriesStyle;

    return series.getStatusStyle(focused, getSeriesStyle);
  }

  function useDatumStyle(datum) {
    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 1),
        _React$useContext2$ = _React$useContext2[0],
        focused = _React$useContext2$.focused,
        getDatumStyle = _React$useContext2$.getDatumStyle;

    return datum.getStatusStyle(focused, getDatumStyle);
  }

  var defaultStyle$4 = {
    r: 2,
    strokeWidth: "1",
    stroke: "#000000",
    fill: "#000000",
    opacity: 1
  };
  function Circle(_ref) {
    var x = _ref.x,
        y = _ref.y,
        r = _ref.r,
        style = _ref.style,
        rest = _objectWithoutProperties(_ref, ["x", "y", "r", "style"]);

    var resolvedStyle = _objectSpread2({}, defaultStyle$4, {}, style);

    return /*#__PURE__*/React.createElement("circle", _extends({}, rest, {
      cx: x || 0,
      cy: y || 0,
      r: 1,
      style: resolvedStyle
    }));
  }

  var pathDefaultStyle = {
    strokeWidth: 2
  };
  var circleDefaultStyle = {
    r: 2
  };
  function Line$1(_ref) {
    var series = _ref.series,
        showPoints = _ref.showPoints,
        curve = _ref.curve;
    var lineFn = React.useMemo(function () {
      return $i().x(function (d) {
        return d.x;
      }).y(function (d) {
        return d.y;
      }).defined(function (d) {
        return d.defined;
      }).curve(curve);
    }, [curve]);
    var path = React.useMemo(function () {
      return lineFn(series.datums);
    }, [lineFn, series.datums]);
    var style = useSeriesStyle(series);
    var pathProps = {
      d: path,
      style: _objectSpread2({}, pathDefaultStyle, {}, style, {}, style.line, {
        fill: "none"
      })
    };
    var renderedPath = usePropsMemo(function () {
      return /*#__PURE__*/React.createElement(Path, pathProps);
    }, pathProps);
    return React.useMemo(function () {
      return /*#__PURE__*/React.createElement("g", null, renderedPath, showPoints && series.datums.map(function (datum, i) {
        return /*#__PURE__*/React.createElement(Point, {
          key: i,
          datum: datum,
          style: style
        });
      }));
    }, [renderedPath, series.datums, showPoints, style]);
  }
  Line$1.defaultProps = {
    curve: Sr
  };

  Line$1.plotDatum = function (datum, _ref2) {
    var primaryAxis = _ref2.primaryAxis,
        secondaryAxis = _ref2.secondaryAxis,
        xAxis = _ref2.xAxis,
        yAxis = _ref2.yAxis;
    datum.primaryCoord = primaryAxis.scale(datum.primary);
    datum.secondaryCoord = secondaryAxis.scale(datum.secondary);
    datum.x = xAxis.scale(datum.xValue);
    datum.y = yAxis.scale(datum.yValue);
    datum.defined = Utils.isValidPoint(datum.xValue) && Utils.isValidPoint(datum.yValue);
    datum.base = primaryAxis.vertical ? xAxis.scale(datum.baseValue) : yAxis.scale(datum.baseValue); // Adjust non-bar elements for ordinal scales

    if (xAxis.type === "ordinal") {
      datum.x += xAxis.tickOffset;
    }

    if (yAxis.type === "ordinal") {
      datum.y += yAxis.tickOffset;
    } // Set the default anchor point


    datum.anchor = {
      x: datum.x,
      y: datum.y
    }; // Set the pointer points (used in voronoi)

    datum.boundingPoints = [datum.anchor];
  };

  Line$1.buildStyles = function (series, _ref3) {
    var defaultColors = _ref3.defaultColors;
    var defaults = {
      // Pass some sane defaults
      color: defaultColors[series.index % (defaultColors.length - 1)]
    };
    Utils.buildStyleGetters(series, defaults);
  };

  function Point(_ref4) {
    var datum = _ref4.datum,
        style = _ref4.style;

    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 2),
        setChartState = _React$useContext2[1];

    var dataStyle = useDatumStyle(datum);
    var circleProps = {
      x: datum ? datum.x : undefined,
      y: datum ? datum.y : undefined,
      style: _objectSpread2({}, circleDefaultStyle, {}, style, {}, style.circle, {}, dataStyle, {}, dataStyle.circle),
      onMouseEnter: function onMouseEnter(e) {
        return setChartState(function (state) {
          return _objectSpread2({}, state, {
            element: datum
          });
        });
      },
      onMouseLeave: function onMouseLeave(e) {
        return setChartState(function (state) {
          return _objectSpread2({}, state, {
            element: null
          });
        });
      }
    };
    return usePropsMemo(function () {
      if (!datum.defined) {
        return null;
      }

      return /*#__PURE__*/React.createElement(Circle, circleProps);
    }, circleProps);
  }

  var circleDefaultStyle$1 = {
    r: 2
  };
  function Bubble(_ref) {
    var series = _ref.series;
    var style = useSeriesStyle(series);
    return /*#__PURE__*/React.createElement("g", null, series.datums.map(function (datum, i) {
      return /*#__PURE__*/React.createElement(Point$1, {
        key: i,
        datum: datum,
        style: style
      });
    }));
  }

  Bubble.plotDatum = function (datum, _ref2) {
    var primaryAxis = _ref2.primaryAxis,
        secondaryAxis = _ref2.secondaryAxis,
        xAxis = _ref2.xAxis,
        yAxis = _ref2.yAxis;
    datum.primaryCoord = primaryAxis.scale(datum.primary);
    datum.secondaryCoord = secondaryAxis.scale(datum.secondary);
    datum.x = xAxis.scale(datum.xValue);
    datum.y = yAxis.scale(datum.yValue);
    datum.defined = Utils.isValidPoint(datum.xValue) && Utils.isValidPoint(datum.yValue);
    datum.base = primaryAxis.vertical ? xAxis.scale(datum.baseValue) : yAxis.scale(datum.baseValue); // Adjust non-bar elements for ordinal scales

    if (xAxis.type === "ordinal") {
      datum.x += xAxis.tickOffset;
    }

    if (yAxis.type === "ordinal") {
      datum.y += yAxis.tickOffset;
    } // Set the default anchor point


    datum.anchor = {
      x: datum.x,
      y: datum.y,
      verticalPadding: datum.r,
      horizontalPadding: datum.r
    }; // Set the pointer points (used in voronoi)

    datum.boundingPoints = [datum.anchor];
  };

  Bubble.buildStyles = function (series, _ref3) {
    var defaultColors = _ref3.defaultColors;
    var defaults = {
      // Pass some sane defaults
      color: defaultColors[series.index % (defaultColors.length - 1)]
    };
    Utils.buildStyleGetters(series, defaults);
  };

  function Point$1(_ref4) {
    var datum = _ref4.datum,
        style = _ref4.style;
    var dataStyle = useDatumStyle(datum);

    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 2),
        setChartState = _React$useContext2[1];

    var circleProps = {
      x: datum ? datum.x : undefined,
      y: datum ? datum.y : undefined,
      style: _objectSpread2({}, circleDefaultStyle$1, {}, typeof datum.r !== "undefined" ? {
        r: datum.r
      } : {}, {}, style, {}, style.circle, {}, dataStyle, {}, dataStyle.circle),
      onMouseEnter: function onMouseEnter(e) {
        return setChartState(function (state) {
          return _objectSpread2({}, state, {
            element: datum
          });
        });
      },
      onMouseLeave: function onMouseLeave(e) {
        return setChartState(function (state) {
          return _objectSpread2({}, state, {
            element: null
          });
        });
      }
    };
    return usePropsMemo(function () {
      if (!datum.defined) {
        return null;
      }

      return /*#__PURE__*/React.createElement(Circle, circleProps);
    }, circleProps);
  }

  var defaultAreaStyle = {
    strokeWidth: 0
  };
  var lineDefaultStyle = {
    strokeWidth: 3
  };
  function Area(_ref) {
    var series = _ref.series,
        showOrphans = _ref.showOrphans,
        curve = _ref.curve;
    var areaFn = React.useMemo(function () {
      return Vi().x(function (d) {
        return d.x;
      }).y0(function (d) {
        return d.base;
      }).y1(function (d) {
        return d.y;
      }).defined(function (d) {
        return d.defined;
      }).curve(curve);
    }, [curve]);
    var lineFn = React.useMemo(function () {
      return $i().x(function (d) {
        return d.x;
      }).y(function (d) {
        return d.y;
      }).defined(function (d) {
        return d.defined;
      }).curve(curve);
    }, [curve]);
    var areaPath = React.useMemo(function () {
      return areaFn(series.datums);
    }, [areaFn, series.datums]);
    var linePath = React.useMemo(function () {
      return lineFn(series.datums);
    }, [lineFn, series.datums]);
    var style = useSeriesStyle(series);
    var areaPathProps = {
      d: areaPath,
      style: _objectSpread2({}, defaultAreaStyle, {}, style, {}, style.line, {}, style.area)
    };
    var renderedAreaPath = usePropsMemo(function () {
      return /*#__PURE__*/React.createElement(Path, areaPathProps);
    }, areaPathProps);
    var linePathProps = {
      d: linePath,
      style: _objectSpread2({}, defaultAreaStyle, {}, style, {}, style.line, {
        fill: "none"
      })
    };
    var renderedLinePath = usePropsMemo(function () {
      return /*#__PURE__*/React.createElement(Path, linePathProps);
    }, linePathProps);
    return /*#__PURE__*/React.createElement("g", null, renderedAreaPath, renderedLinePath, showOrphans && series.datums.map(function (datum, index, all) {
      return /*#__PURE__*/React.createElement(OrphanLine, {
        key: index,
        datum: datum,
        style: style,
        all: all,
        index: index
      });
    }));
  }
  Area.defaultProps = {
    showOrphans: true,
    curve: Oi
  };

  Area.plotDatum = function (datum, _ref2) {
    var primaryAxis = _ref2.primaryAxis,
        secondaryAxis = _ref2.secondaryAxis,
        xAxis = _ref2.xAxis,
        yAxis = _ref2.yAxis;
    // Turn clamping on for secondaryAxis
    secondaryAxis.scale.clamp(true);
    datum.primaryCoord = primaryAxis.scale(datum.primary);
    datum.secondaryCoord = secondaryAxis.scale(datum.secondary);
    datum.x = xAxis.scale(datum.xValue);
    datum.y = yAxis.scale(datum.yValue);
    datum.defined = Utils.isValidPoint(datum.xValue) && Utils.isValidPoint(datum.yValue);
    datum.base = primaryAxis.vertical ? xAxis.scale(datum.baseValue) : yAxis.scale(datum.baseValue); // Turn clamping back off for secondaryAxis

    secondaryAxis.scale.clamp(false); // Adjust non-bar elements for ordinal scales

    if (xAxis.type === "ordinal") {
      datum.x += xAxis.tickOffset;
    }

    if (yAxis.type === "ordinal") {
      datum.y += yAxis.tickOffset;
    } // Set the default anchor point


    datum.anchor = {
      x: datum.x,
      y: datum.y
    }; // Set the pointer points (used in voronoi)

    datum.boundingPoints = [datum.anchor, {
      x: primaryAxis.vertical ? primaryAxis.position === "left" ? datum.base - 1 : datum.base : datum.anchor.x,
      y: !primaryAxis.vertical ? primaryAxis.position === "bottom" ? datum.base - 1 : datum.base : datum.anchor.y
    }];
  };

  Area.buildStyles = function (series, _ref3) {
    var defaultColors = _ref3.defaultColors;
    var defaults = {
      // Pass some sane defaults
      color: defaultColors[series.index % (defaultColors.length - 1)]
    };
    Utils.buildStyleGetters(series, defaults);
  };

  var OrphanLine = function OrphanLine(_ref4) {
    var datum = _ref4.datum,
        style = _ref4.style,
        all = _ref4.all,
        index = _ref4.index;
    var prev = all[index - 1] || {
      defined: false
    };
    var next = all[index + 1] || {
      defined: false
    };
    var dataStyle = useDatumStyle(datum);
    var lineProps = {
      x1: !datum || Number.isNaN(datum.x) ? null : datum.x,
      y1: !datum || Number.isNaN(datum.base) ? null : datum.base,
      x2: !datum || Number.isNaN(datum.x) ? null : datum.x,
      y2: !datum || Number.isNaN(datum.y) ? null : datum.y,
      style: _objectSpread2({}, lineDefaultStyle, {}, style, {}, style.line, {}, dataStyle, {}, dataStyle.line)
    };
    return usePropsMemo(function () {
      if (!datum.defined || prev.defined || next.defined) {
        return null;
      }

      return /*#__PURE__*/React.createElement(Line, lineProps);
    }, lineProps);
  };

  function Bar(_ref) {
    var series = _ref.series;

    var _React$useContext = React.useContext(ChartContext),
        _React$useContext2 = _slicedToArray(_React$useContext, 1),
        primaryAxes = _React$useContext2[0].primaryAxes;

    var style = useSeriesStyle(series);

    var _ref2 = series.primaryAxisID ? primaryAxes.find(function (d) {
      return d.id === series.primaryAxisID;
    }) : primaryAxes[0],
        barOffset = _ref2.barOffset;

    return /*#__PURE__*/React.createElement("g", {
      className: "series bar"
    }, series.datums.map(function (datum, i) {
      return /*#__PURE__*/React.createElement(BarPiece, _extends({
        key: i
      }, {
        datum: datum,
        barOffset: barOffset,
        style: style
      }));
    }));
  }

  function BarPiece(_ref3) {
    var datum = _ref3.datum,
        barOffset = _ref3.barOffset,
        style = _ref3.style;

    var _React$useContext3 = React.useContext(ChartContext),
        _React$useContext4 = _slicedToArray(_React$useContext3, 2),
        primaryAxes = _React$useContext4[0].primaryAxes,
        setChartState = _React$useContext4[1];

    var x = datum ? datum.x : 0;
    var y = datum ? datum.y : 0;
    var base = datum ? datum.base : 0;
    var size = datum ? datum.size : 0;
    var x1;
    var y1;
    var x2;
    var y2;

    if (primaryAxes.find(function (d) {
      return d.vertical;
    })) {
      x1 = base;
      x2 = x;
      y1 = y + barOffset;
      y2 = y1 + size;
    } else {
      x1 = x + barOffset;
      x2 = x1 + size;
      y1 = y;
      y2 = base;
    }

    var dataStyle = useDatumStyle(datum);
    var rectangleProps = {
      style: _objectSpread2({
        pointerEvents: "all"
      }, style, {}, style.rectangle, {}, dataStyle, {}, dataStyle.rectangle),
      x1: Number.isNaN(x1) ? null : x1,
      y1: Number.isNaN(y1) ? null : y1,
      x2: Number.isNaN(x2) ? null : x2,
      y2: Number.isNaN(y2) ? null : y2,
      onMouseEnter: function onMouseEnter(e) {
        return setChartState(function (state) {
          return _objectSpread2({}, state, {
            element: datum
          });
        });
      },
      onMouseLeave: function onMouseLeave(e) {
        return setChartState(function (state) {
          return _objectSpread2({}, state, {
            element: null
          });
        });
      }
    };
    return usePropsMemo(function () {
      return /*#__PURE__*/React.createElement(Rectangle, rectangleProps);
    }, rectangleProps);
  }

  Bar.plotDatum = function (datum, _ref4) {
    var xAxis = _ref4.xAxis,
        yAxis = _ref4.yAxis,
        primaryAxis = _ref4.primaryAxis,
        secondaryAxis = _ref4.secondaryAxis;
    // Turn clamping on for secondaryAxis
    secondaryAxis.scale.clamp(true);
    datum.primaryCoord = primaryAxis.scale(datum.primary);
    datum.secondaryCoord = secondaryAxis.scale(datum.secondary);
    datum.x = xAxis.scale(datum.xValue);
    datum.y = yAxis.scale(datum.yValue);
    datum.defined = Utils.isValidPoint(datum.xValue) && Utils.isValidPoint(datum.yValue);
    datum.base = secondaryAxis.scale(datum.baseValue);
    datum.size = primaryAxis.barSize; // Turn clamping back off for secondaryAxis

    secondaryAxis.scale.clamp(false);

    if (!secondaryAxis.stacked) {
      datum.size = primaryAxis.seriesBarSize; // Use the seriesTypeIndex here in case we have mixed types.

      var seriesBandScaleOffset = primaryAxis.seriesBandScale(datum.seriesTypeIndex);

      if (secondaryAxis.vertical) {
        datum.x += seriesBandScaleOffset;
      } else {
        datum.y += seriesBandScaleOffset;
      }
    } // Set the default anchor point


    datum.anchor = {
      x: datum.x,
      y: datum.y,
      horizontalPadding: secondaryAxis.vertical ? datum.size / 2 : 0,
      verticalPadding: secondaryAxis.vertical ? 0 : datum.size / 2
    }; // Adjust the anchor point for bars

    if (!primaryAxis.vertical) {
      datum.anchor.x += primaryAxis.type !== "ordinal" ? 0 : datum.size / 2;
    } else {
      datum.anchor.y += primaryAxis.type !== "ordinal" ? 0 : datum.size / 2;
    } // Set the pointer points (used in voronoi)


    datum.boundingPoints = [// End of bar
    datum.anchor, // Start of bar
    {
      x: primaryAxis.vertical ? primaryAxis.position === "left" ? datum.base + 1 : datum.base : datum.anchor.x,
      y: !primaryAxis.vertical ? primaryAxis.position === "bottom" ? datum.base - 1 : datum.base : datum.anchor.y
    }];
  };

  Bar.buildStyles = function (series, _ref5) {
    var defaultColors = _ref5.defaultColors;
    var defaults = {
      // Pass some sane defaults
      color: defaultColors[series.index % (defaultColors.length - 1)]
    };
    Utils.buildStyleGetters(series, defaults);
  };

  var seriesTypes = {
    line: Line$1,
    bubble: Bubble,
    area: Area,
    bar: Bar // pie: Pie

  };
  var defaultSeries = {
    type: 'line',
    showPoints: true,
    showOrphans: true,
    curve: Sr
  };
  var useSeriesOptions = (function (_ref) {
    var materializedData = _ref.materializedData,
        series = _ref.series;
    return React.useMemo(function () {
      return materializedData.map(function (s, seriesIndex) {
        var _defaultSeries = _objectSpread2({}, defaultSeries, {}, typeof series === 'function' ? series(s, seriesIndex) : series),
            type = _defaultSeries.type,
            rest = _objectWithoutProperties(_defaultSeries, ["type"]);

        var renderer = seriesTypes[type];

        if (!renderer) {
          throw new Error("Could not find a registered series type for ".concat(type));
        }

        return _objectSpread2({}, rest, {
          type: type,
          renderer: renderer
        });
      });
    }, [materializedData, series]);
  });

  var useSeriesTypes = (function (_ref) {
    var materializedData = _ref.materializedData,
        seriesOptions = _ref.seriesOptions;
    return React.useMemo(function () {
      return materializedData.map(function (series, i) {
        series.Component = seriesOptions[i].renderer;
        return series;
      }).map(function (series, i, all) {
        var seriesTypeIndex = all.filter(function (d, j) {
          return j < i && d.Component === series.Component;
        }).length;
        return _objectSpread2({}, series, {
          seriesTypeIndex: seriesTypeIndex,
          datums: series.datums.map(function (datum) {
            return _objectSpread2({}, datum, {
              seriesTypeIndex: seriesTypeIndex
            });
          })
        });
      });
    }, [materializedData, seriesOptions]);
  });

  var useDimensions = (function (_ref) {
    var width = _ref.width,
        height = _ref.height,
        axisDimensions = _ref.axisDimensions,
        padding = _ref.padding,
        offset = _ref.offset;
    offset = React.useMemo(function () {
      return {
        left: offset.left || 0,
        top: offset.top || 0
      };
    }, [offset]);

    var _React$useMemo = React.useMemo(function () {
      // Left
      var axesLeftWidth = axisDimensions.left && Utils.sumObjBy(axisDimensions.left, 'width') || 0;
      var axesLeftTop = axisDimensions.left && Utils.sumObjBy(axisDimensions.left, 'top') || 0;
      var axesLeftBottom = axisDimensions.left && Utils.sumObjBy(axisDimensions.left, 'bottom') || 0; // Right

      var axesRightWidth = axisDimensions.right && Utils.sumObjBy(axisDimensions.right, 'width') || 0;
      var axesRightTop = axisDimensions.right && Utils.sumObjBy(axisDimensions.right, 'top') || 0;
      var axesRightBottom = axisDimensions.right && Utils.sumObjBy(axisDimensions.right, 'bottom') || 0; // Top

      var axesTopHeight = axisDimensions.top && Utils.sumObjBy(axisDimensions.top, 'height') || 0;
      var axesTopLeft = axisDimensions.top && Utils.sumObjBy(axisDimensions.top, 'left') || 0;
      var axesTopRight = axisDimensions.top && Utils.sumObjBy(axisDimensions.top, 'right') || 0; // Bottom

      var axesBottomHeight = axisDimensions.bottom && Utils.sumObjBy(axisDimensions.bottom, 'height') || 0;
      var axesBottomLeft = axisDimensions.bottom && Utils.sumObjBy(axisDimensions.bottom, 'left') || 0;
      var axesBottomRight = axisDimensions.bottom && Utils.sumObjBy(axisDimensions.bottom, 'right') || 0;
      var paddingLeft = padding.left || 0;
      var paddingRight = padding.right || 0;
      var paddingTop = padding.top || 0;
      var paddingBottom = padding.bottom || 0;
      var gridX = paddingLeft + Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft);
      var gridY = paddingTop + Math.max(axesTopHeight, axesLeftTop, axesRightTop);
      var gridWidth = width - paddingLeft - paddingRight - Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft) - Math.max(axesRightWidth, axesTopRight, axesBottomRight);
      var gridHeight = height - paddingTop - paddingBottom - Math.max(axesTopHeight, axesLeftTop, axesRightTop) - Math.max(axesBottomHeight, axesLeftBottom, axesRightBottom);
      return {
        gridX: gridX,
        gridY: gridY,
        gridWidth: gridWidth,
        gridHeight: gridHeight
      };
    }, [width, height, axisDimensions, padding]),
        gridX = _React$useMemo.gridX,
        gridY = _React$useMemo.gridY,
        gridWidth = _React$useMemo.gridWidth,
        gridHeight = _React$useMemo.gridHeight;

    return {
      offset: offset,
      gridX: gridX,
      gridY: gridY,
      gridWidth: gridWidth,
      gridHeight: gridHeight
    };
  });

  var _scales;
  var scales = (_scales = {}, _defineProperty(_scales, axisTypeLinear, yn), _defineProperty(_scales, axisTypeLog, bn), _defineProperty(_scales, axisTypeTime, _i), _defineProperty(_scales, axisTypeUtc, yi), _defineProperty(_scales, axisTypeOrdinal, J), _scales);

  var detectVertical = function detectVertical(d) {
    return [positionLeft, positionRight].indexOf(d) > -1;
  };

  var detectRTL = function detectRTL(d) {
    return [positionTop, positionRight].indexOf(d) > -1;
  };

  function buildAxisLinear(_ref) {
    var _ref$axis = _ref.axis,
        primary = _ref$axis.primary,
        type = _ref$axis.type,
        invert = _ref$axis.invert,
        position = _ref$axis.position,
        primaryAxisID = _ref$axis.primaryAxisID,
        _ref$axis$min = _ref$axis.min,
        userMin = _ref$axis$min === void 0 ? undefined : _ref$axis$min,
        _ref$axis$max = _ref$axis.max,
        userMax = _ref$axis$max === void 0 ? undefined : _ref$axis$max,
        _ref$axis$hardMin = _ref$axis.hardMin,
        hardMin = _ref$axis$hardMin === void 0 ? undefined : _ref$axis$hardMin,
        _ref$axis$hardMax = _ref$axis.hardMax,
        hardMax = _ref$axis$hardMax === void 0 ? undefined : _ref$axis$hardMax,
        _ref$axis$base = _ref$axis.base,
        base = _ref$axis$base === void 0 ? undefined : _ref$axis$base,
        _ref$axis$tickCount = _ref$axis.tickCount,
        tickCount = _ref$axis$tickCount === void 0 ? 'auto' : _ref$axis$tickCount,
        _ref$axis$minTickCoun = _ref$axis.minTickCount,
        minTickCount = _ref$axis$minTickCoun === void 0 ? 0 : _ref$axis$minTickCoun,
        _ref$axis$maxTickCoun = _ref$axis.maxTickCount,
        maxTickCount = _ref$axis$maxTickCoun === void 0 ? Infinity : _ref$axis$maxTickCoun,
        _ref$axis$tickValues = _ref$axis.tickValues,
        tickValues = _ref$axis$tickValues === void 0 ? null : _ref$axis$tickValues,
        _ref$axis$format = _ref$axis.format,
        userFormat = _ref$axis$format === void 0 ? null : _ref$axis$format,
        _ref$axis$tickSizeInn = _ref$axis.tickSizeInner,
        tickSizeInner = _ref$axis$tickSizeInn === void 0 ? 6 : _ref$axis$tickSizeInn,
        _ref$axis$tickSizeOut = _ref$axis.tickSizeOuter,
        tickSizeOuter = _ref$axis$tickSizeOut === void 0 ? 6 : _ref$axis$tickSizeOut,
        _ref$axis$tickPadding = _ref$axis.tickPadding,
        tickPadding = _ref$axis$tickPadding === void 0 ? 14 : _ref$axis$tickPadding,
        _ref$axis$maxLabelRot = _ref$axis.maxLabelRotation,
        maxLabelRotation = _ref$axis$maxLabelRot === void 0 ? 50 : _ref$axis$maxLabelRot,
        _ref$axis$labelRotati = _ref$axis.labelRotationStep,
        labelRotationStep = _ref$axis$labelRotati === void 0 ? 5 : _ref$axis$labelRotati,
        _ref$axis$innerPaddin = _ref$axis.innerPadding,
        innerPadding = _ref$axis$innerPaddin === void 0 ? 0.2 : _ref$axis$innerPaddin,
        _ref$axis$outerPaddin = _ref$axis.outerPadding,
        outerPadding = _ref$axis$outerPaddin === void 0 ? 0.1 : _ref$axis$outerPaddin,
        _ref$axis$showGrid = _ref$axis.showGrid,
        showGrid = _ref$axis$showGrid === void 0 ? null : _ref$axis$showGrid,
        _ref$axis$showTicks = _ref$axis.showTicks,
        showTicks = _ref$axis$showTicks === void 0 ? true : _ref$axis$showTicks,
        _ref$axis$show = _ref$axis.show,
        show = _ref$axis$show === void 0 ? true : _ref$axis$show,
        _ref$axis$stacked = _ref$axis.stacked,
        stacked = _ref$axis$stacked === void 0 ? false : _ref$axis$stacked,
        userID = _ref$axis.id,
        materializedData = _ref.materializedData,
        gridHeight = _ref.gridHeight,
        gridWidth = _ref.gridWidth,
        axisDimensions = _ref.axisDimensions;

    if (!position) {
      throw new Error("Chart axes must have a valid 'position' property");
    } // Detect some settings


    var valueKey = primary ? 'primary' : 'secondary';
    var groupKey = !primary && 'primary';
    var AxisIDKey = "".concat(valueKey, "AxisID");
    var vertical = detectVertical(position);
    var RTL = detectRTL(position); // Right to left OR top to bottom

    var id = userID || "".concat(position, "_").concat(type); // TODO: Any sorting needs to happen here, else the min/max's might not line up correctly
    // First we need to find unique values, min/max values and negative/positive totals

    var uniqueVals = [];
    var min;
    var max;
    var negativeTotalByKey = {};
    var positiveTotalByKey = {};
    var domain; // const axisDimension =
    //   axisDimensions && axisDimensions[position] && axisDimensions[position][id]
    // Loop through each series

    for (var seriesIndex = 0; seriesIndex < materializedData.length; seriesIndex++) {
      if (materializedData[seriesIndex][AxisIDKey] && materializedData[seriesIndex][AxisIDKey] !== id) {
        continue;
      } // Loop through each datum


      for (var datumIndex = 0; datumIndex < materializedData[seriesIndex].datums.length; datumIndex++) {
        var datum = materializedData[seriesIndex].datums[datumIndex];
        var value = void 0;
        var key = groupKey ? datum[groupKey] : datumIndex; // For ordinal scales, unique the values

        if (type === axisTypeOrdinal) {
          if (uniqueVals.indexOf() === -1) {
            uniqueVals.push(materializedData[seriesIndex].datums[datumIndex][valueKey]);
          }
        } else if (type === axisTypeTime || type === axisTypeUtc) {
          value = +datum[valueKey];
        } else {
          value = datum[valueKey];
        } // Add to stack total


        if (stacked) {
          if (value > 0) {
            positiveTotalByKey[key] = typeof positiveTotalByKey[key] !== 'undefined' ? positiveTotalByKey[key] + value : value;
          } else {
            negativeTotalByKey[key] = typeof negativeTotalByKey[key] !== 'undefined' ? negativeTotalByKey[key] + value : value;
          }
        } else {
          // Find min/max
          min = typeof min !== 'undefined' ? Math.min(min, value) : value;
          max = typeof max !== 'undefined' ? Math.max(max, value) : value;
        }
      }
    }

    if (type === axisTypeOrdinal) {
      domain = uniqueVals;
    } else if (stacked) {
      domain = [Math.min.apply(Math, [0].concat(_toConsumableArray(Object.values(negativeTotalByKey)))), Math.max.apply(Math, [0].concat(_toConsumableArray(Object.values(positiveTotalByKey))))];
    } else {
      domain = [min, max];
    } // Now we need to figure out the range


    var range = [0, vertical ? gridHeight : gridWidth]; // axes by default read from top to bottom and left to right

    if (vertical && !primary) {
      // Vertical secondary ranges get inverted by default
      range.reverse();
    } // Give the scale a home


    var scale; // If this is an ordinal or other primary axis, it needs to be able to display bars.

    var bandScale;
    var barSize = 0;
    var cursorSize = 0;
    var stepSize = 0;

    var seriesBandScale = function seriesBandScale(d) {
      return d;
    };

    var seriesBarSize = 1;

    if (type === axisTypeOrdinal || primary) {
      // Calculate a band axis that is similar and pass down the bandwidth
      // just in case.
      bandScale = J().domain(materializedData.reduce(function (prev, current) {
        return current.datums.length > prev.length ? current.datums : prev;
      }, []).map(function (d) {
        return d.primary;
      })).rangeRound(range, 0.1).padding(0);
      bandScale.paddingOuter(outerPadding).paddingInner(innerPadding);
      barSize = bandScale.bandwidth();

      if (type === axisTypeOrdinal) {
        cursorSize = barSize;
      } // barSize = bandScale.bandwidth()


      stepSize = bandScale.step(); // Create a seriesBandScale in case this axis isn't stacked

      seriesBandScale = J().paddingInner(innerPadding / 2).domain(materializedData.filter(function (d) {
        return d.Component === Bar;
      }).map(function (d, i) {
        return i;
      })).rangeRound([0, barSize]);
      seriesBarSize = seriesBandScale.bandwidth();
    }

    if (type === axisTypeOrdinal) {
      // If it's ordinal, just assign the bandScale we made
      scale = bandScale;
    } else {
      // Otherwise, create a new scale of the appropriate type
      scale = scales[type]();
    } // Set base, min, and max


    if (typeof base === 'number') {
      domain[0] = Math.min(domain[0], base);
      domain[1] = Math.max(domain[1], base);
    }

    if (typeof defaultMin === 'number') {
      domain[0] = Math.min(domain[0], userMin);
    }

    if (typeof defaultMax === 'number') {
      domain[1] = Math.max(domain[1], userMax);
    } // Set the domain


    scale.domain(domain); // If we're not using an ordinal scale, round the ticks to "nice" values

    if (type !== axisTypeOrdinal) {
      scale.nice();
    } // If hard min and max are set, override any "nice" rounding values


    if (typeof hardMin === 'number') {
      scale.domain([hardMin, scale.domain()[1]]);
    }

    if (typeof hardMax === 'number') {
      scale.domain([scale.domain()[0], hardMax]);
    } // Invert if necessary


    if (invert) {
      scale.domain(_toConsumableArray(scale.domain()).reverse());
    } // Now set the range


    scale.range(range);
    var scaleFormat = scale.tickFormat ? scale.tickFormat() : Utils.identity;
    var format = userFormat ? function () {
      return userFormat(scaleFormat.apply(void 0, arguments));
    } : scaleFormat; // Pass down the axis config (including the scale itself) for posterity

    var axis = {
      id: id,
      primary: primary,
      type: type,
      invert: invert,
      position: position,
      primaryAxisID: primaryAxisID,
      hardMin: hardMin,
      hardMax: hardMax,
      base: base,
      tickCount: tickCount,
      minTickCount: minTickCount,
      maxTickCount: maxTickCount,
      tickValues: tickValues,
      tickSizeInner: tickSizeInner,
      tickSizeOuter: tickSizeOuter,
      tickPadding: tickPadding,
      maxLabelRotation: maxLabelRotation,
      labelRotationStep: labelRotationStep,
      innerPadding: innerPadding,
      outerPadding: outerPadding,
      showGrid: showGrid,
      showTicks: showTicks,
      show: show,
      stacked: stacked,
      scale: scale,
      uniqueVals: uniqueVals,
      vertical: vertical,
      RTL: RTL,
      barSize: barSize,
      cursorSize: cursorSize,
      stepSize: stepSize,
      seriesBandScale: seriesBandScale,
      seriesBarSize: seriesBarSize,
      domain: domain,
      range: range,
      max: position === positionBottom ? -gridHeight : position === positionLeft ? gridWidth : position === positionTop ? gridHeight : -gridWidth,
      directionMultiplier: position === positionTop || position === positionLeft ? -1 : 1,
      transform: !vertical ? Utils.translateX : Utils.translateY,
      ticks: tickValues || scale.ticks ? scale.ticks // tickCount === 'auto'
      //   ? axisDimension
      //     ? axisDimension.tickCount
      //     : 10
      //   : tickCount
      () : scale.domain(),
      format: format,
      spacing: Math.max(tickSizeInner, 0) + tickPadding
    };

    if (type === axisTypeOrdinal) {
      axis.gridOffset = -(axis.stepSize * innerPadding) / 2;
      axis.tickOffset = axis.barSize / 2;
      axis.barOffset = 0;
    } else {
      axis.tickOffset = 0;
      axis.barOffset = -axis.barSize / 2;
    }

    return axis;
  }

  // import buildAxisPie from './buildAxis.pie'
  function buildAxis (config) {
    // if (config.type === 'pie') {
    // return buildAxisPie(config)
    // }
    return buildAxisLinear(config);
  }

  var useAxes = (function (_ref) {
    var axes = _ref.axes,
        materializedData = _ref.materializedData,
        gridHeight = _ref.gridHeight,
        gridWidth = _ref.gridWidth,
        axisDimensions = _ref.axisDimensions;
    // Detect axes changes and build axes
    var prePrimaryAxes = axes.filter(function (d) {
      return d.primary;
    });
    var preSecondaryAxes = axes.filter(function (d) {
      return !d.primary;
    });
    var primaryAxesHashes = JSON.stringify(prePrimaryAxes);
    var secondaryAxesHashes = JSON.stringify(preSecondaryAxes); // Calculate primary axes

    var primaryAxes = React.useMemo(function () {
      return prePrimaryAxes.map(function (axis, i) {
        return buildAxis({
          axis: axis,
          materializedData: materializedData,
          gridWidth: gridWidth,
          gridHeight: gridHeight,
          axisDimensions: axisDimensions
        });
      });
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [primaryAxesHashes, materializedData, gridHeight, gridWidth]); // Calculate secondary axes

    var secondaryAxes = React.useMemo(function () {
      return preSecondaryAxes.map(function (axis, i) {
        return buildAxis({
          axis: axis,
          primaryAxes: primaryAxes,
          materializedData: materializedData,
          gridWidth: gridWidth,
          gridHeight: gridHeight,
          axisDimensions: axisDimensions
        });
      });
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [secondaryAxesHashes, materializedData, gridHeight, gridWidth]); // Make sure we're mapping x and y to the correct axes

    var xKey = primaryAxes.find(function (d) {
      return d.vertical;
    }) ? 'secondary' : 'primary';
    var yKey = primaryAxes.find(function (d) {
      return d.vertical;
    }) ? 'primary' : 'secondary';
    var xAxes = primaryAxes.find(function (d) {
      return d.vertical;
    }) ? secondaryAxes : primaryAxes;
    var yAxes = primaryAxes.find(function (d) {
      return d.vertical;
    }) ? primaryAxes : secondaryAxes;
    return {
      primaryAxes: primaryAxes,
      secondaryAxes: secondaryAxes,
      xKey: xKey,
      yKey: yKey,
      xAxes: xAxes,
      yAxes: yAxes
    };
  });

  var defaultColors = ['#4ab5eb', '#fc6868', '#DECF3F', '#60BD68', '#FAA43A', '#c63b89', '#1aaabe', '#734fe9', '#1828bd', '#cd82ad'];
  var useStackData = (function (_ref) {
    var materializedData = _ref.materializedData,
        primaryAxes = _ref.primaryAxes,
        secondaryAxes = _ref.secondaryAxes,
        yAxes = _ref.yAxes,
        yKey = _ref.yKey,
        xAxes = _ref.xAxes,
        xKey = _ref.xKey,
        grouping = _ref.grouping;
    // Make stackData
    return React.useMemo(function () {
      // We need materializedData and both axes to continue
      if (!primaryAxes.length || !secondaryAxes.length) {
        throw new Error('A primary and secondary axis is required!');
      } // If the axes are ready, let's decorate the materializedData for visual plotting
      // "totals" are kept per secondaryAxis and used for bases if secondaryAxis stacking is enabled


      var scaleTotals = secondaryAxes.map(function () {
        return {};
      });
      materializedData.forEach(function (series) {
        var axisIndex = Utils.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);
        series.datums.forEach(function (datum) {
          scaleTotals[axisIndex][datum.primary] = {
            negative: 0,
            positive: 0
          };
        });
      }); // Determine the correct primary and secondary values for each axis
      // Also calculate bases and totals if either axis is stacked

      var stackData = materializedData.map(function (series) {
        var primaryAxisIndex = Utils.getAxisIndexByAxisID(primaryAxes, series.primaryAxisID);
        var primaryAxis = primaryAxes[primaryAxisIndex];
        var secondaryAxisIndex = Utils.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);
        var secondaryAxis = secondaryAxes[secondaryAxisIndex];
        return _objectSpread2({}, series, {
          primaryAxis: primaryAxis,
          secondaryAxis: secondaryAxis,
          datums: series.datums.map(function (d) {
            var datum = _objectSpread2({}, d, {
              primaryAxis: primaryAxis,
              secondaryAxis: secondaryAxis,
              xValue: d[xKey],
              yValue: d[yKey],
              baseValue: 0
            });

            if (secondaryAxis.stacked) {
              var start = scaleTotals[secondaryAxisIndex][d.primary]; // Stack the x or y values (according to axis positioning)

              if (primaryAxis.vertical) {
                // Is this a valid point?
                var validPoint = Utils.isValidPoint(datum.xValue); // Should we use positive or negative base?

                var totalKey = datum.xValue >= 0 ? 'positive' : 'negative'; // Assign the base

                datum.baseValue = start[totalKey]; // Add the value for a total

                datum.totalValue = datum.baseValue + (validPoint ? datum.xValue : 0); // Update the totals

                scaleTotals[secondaryAxisIndex][d.primary][totalKey] = datum.totalValue; // Make the total the new value

                datum.xValue = validPoint ? datum.totalValue : null;
              } else {
                // Is this a valid point?
                var _validPoint = Utils.isValidPoint(datum.yValue); // Should we use positive or negative base?


                var _totalKey = datum.yValue >= 0 ? 'positive' : 'negative'; // Assign the base


                datum.baseValue = start[_totalKey]; // Add the value to the base

                datum.totalValue = datum.baseValue + (_validPoint ? datum.yValue : 0); // Update the totals

                scaleTotals[secondaryAxisIndex][d.primary][_totalKey] = datum.totalValue; // Make the total the new value

                datum.yValue = _validPoint ? datum.totalValue : null;
              }
            }

            return datum;
          })
        });
      });
      stackData.forEach(function (series) {
        series.datums.forEach(function (datum) {
          datum.series = series;
        });
      }); // Use the plotDatum method on each series

      stackData.forEach(function (series, i) {
        if (!series.Component.plotDatum) {
          throw new Error("Could not find a [SeriesType].plotDatum() static method for the series Component above (index: ".concat(i, ")"));
        }

        var primaryAxisIndex = Utils.getAxisIndexByAxisID(primaryAxes, series.primaryAxisID);
        var secondaryAxisIndex = Utils.getAxisIndexByAxisID(secondaryAxes, series.secondaryAxisID);
        var primaryAxis = primaryAxes[primaryAxisIndex];
        var secondaryAxis = secondaryAxes[secondaryAxisIndex];
        var xAxisIndex = Utils.getAxisIndexByAxisID(xAxes, series["".concat(xKey, "AxisID")]);
        var yAxisIndex = Utils.getAxisIndexByAxisID(yAxes, series["".concat(yKey, "AxisID")]);
        var xAxis = xAxes[xAxisIndex];
        var yAxis = yAxes[yAxisIndex];
        series.datums = series.datums.map(function (d) {
          // Data for cartesian charts
          var result = series.Component.plotDatum(d, {
            primaryAxis: primaryAxis,
            secondaryAxis: secondaryAxis,
            xAxis: xAxis,
            yAxis: yAxis
          });
          return result || d;
        });
      }); // Do any data grouping ahead of time using

      if ([groupingSingle, groupingSeries].includes(grouping)) {
        for (var seriesIndex = 0; seriesIndex < stackData.length; seriesIndex++) {
          var series = stackData[seriesIndex];

          for (var datumIndex = 0; datumIndex < series.datums.length; datumIndex++) {
            var datum = series.datums[datumIndex];
            datum.group = grouping === groupingSeries ? datum.series.datums : [datum];
          }
        }
      } else if ([groupingPrimary, groupingSecondary].includes(grouping)) {
        var datumsByGrouping = {};

        for (var _seriesIndex = 0; _seriesIndex < stackData.length; _seriesIndex++) {
          var _series = stackData[_seriesIndex];

          for (var _datumIndex = 0; _datumIndex < _series.datums.length; _datumIndex++) {
            var _datum = _series.datums[_datumIndex];

            if (!_datum.defined) {
              continue;
            }

            var axisKey = String(grouping === groupingPrimary ? _datum.primary : _datum.secondary);
            datumsByGrouping[axisKey] = datumsByGrouping[axisKey] || [];
            datumsByGrouping[axisKey].push(_datum);
          }
        }

        for (var _seriesIndex2 = 0; _seriesIndex2 < stackData.length; _seriesIndex2++) {
          var _series2 = stackData[_seriesIndex2];

          for (var _datumIndex2 = 0; _datumIndex2 < _series2.datums.length; _datumIndex2++) {
            var _datum2 = _series2.datums[_datumIndex2];

            var _axisKey = String(grouping === groupingPrimary ? _datum2.primary : _datum2.secondary);

            _datum2.group = datumsByGrouping[_axisKey];
          }
        }
      } // Not we need to precalculate all of the possible status styles by
      // calling the seemingly 'live' getSeriesStyle, and getDatumStyle callbacks ;)


      stackData = stackData.map(function (series, i) {
        if (!series.Component.buildStyles) {
          throw new Error("Could not find a SeriesType.buildStyles() static method for the series Component above (index: ".concat(i, ")"));
        }

        var result = series.Component.buildStyles(series, {
          defaultColors: defaultColors
        });
        return result || series;
      });
      return stackData;
    }, [primaryAxes, secondaryAxes, materializedData, grouping, xKey, yKey, xAxes, yAxes]);
  });

  var showCount = 10;

  function getSecondaryFormatter(datum, formatSecondary) {
    return formatSecondary || datum.secondaryAxis.format || function (val) {
      return Math.floor(val) < val ? Math.round(val * 100) / 100 : val;
    };
  }

  function TooltipRenderer(props) {
    var datum = props.datum,
        grouping = props.grouping,
        primaryAxis = props.primaryAxis,
        secondaryAxis = props.secondaryAxis,
        formatSecondary = props.formatSecondary,
        formatTertiary = props.formatTertiary,
        getStyle = props.getStyle,
        dark = props.dark;

    if (!datum) {
      return null;
    }

    var resolvedFormatTertiary = formatTertiary || function (val) {
      return Math.floor(val) < val ? Math.round(val * 100) / 100 : val;
    };

    var sortedGroupDatums = _toConsumableArray(datum.group).sort(function (a, b) {
      if (!primaryAxis.stacked && grouping === groupingSeries || grouping === groupingSecondary) {
        if (a.primaryCoord > b.primaryCoord) {
          return -1;
        } else if (a.primaryCoord < b.primaryCoord) {
          return 1;
        }
      } else if (!secondaryAxis.stacked) {
        if (a.secondaryCoord > b.secondaryCoord) {
          return -1;
        } else if (a.secondaryCoord < b.secondaryCoord) {
          return 1;
        }
      }

      return a.seriesIndex > b.seriesIndex ? 1 : -1;
    });

    if (grouping === groupingPrimary) {
      sortedGroupDatums.reverse();
    }

    if (secondaryAxis.invert) {
      sortedGroupDatums.reverse();
    }

    var resolvedShowCount =  showCount ;
    var length = sortedGroupDatums.length; // Get the focused series' index

    var activeIndex = sortedGroupDatums.findIndex(function (d) {
      return d === datum;
    }); // Get the start by going back half of the showCount

    var start = activeIndex > -1 ? activeIndex - resolvedShowCount / 2 : 0; // Make sure it's at least 0

    start = Math.max(start, 0); // Use the start and add the showCount to get the end

    var end = activeIndex > -1 ? start + resolvedShowCount : length; // Don't let the end go passed the length

    end = Math.min(end, length); // Double check we aren't clipping the start

    start = Math.max(end - resolvedShowCount, 0); // Slice the datums by start and end

    var visibleSortedGroupDatums = sortedGroupDatums.slice(start, end); // Detect if we have previous items

    var hasPrevious = start > 0; // Or next items

    var hasNext = end < length;
    return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
      style: {
        marginBottom: '3px',
        textAlign: 'center'
      }
    }, grouping === groupingSeries ? /*#__PURE__*/React.createElement("strong", null, datum.seriesLabel) : grouping === groupingSecondary ? /*#__PURE__*/React.createElement("strong", null, datum.secondaryAxis.format(datum.secondary)) : /*#__PURE__*/React.createElement("strong", null, datum.primaryAxis.format(datum.primary))), /*#__PURE__*/React.createElement("table", {
      style: {
        whiteSpace: 'nowrap'
      }
    }, /*#__PURE__*/React.createElement("tbody", null, hasPrevious ? /*#__PURE__*/React.createElement("tr", {
      style: {
        opacity: 0.8
      }
    }, /*#__PURE__*/React.createElement("td", null), /*#__PURE__*/React.createElement("td", null, "..."), /*#__PURE__*/React.createElement("td", null)) : null, visibleSortedGroupDatums.map(function (sortedDatum, i) {
      var active = sortedDatum === datum;
      var resolvedSecondaryFormat = getSecondaryFormatter(sortedDatum, formatSecondary);
      return /*#__PURE__*/React.createElement("tr", {
        key: i,
        style: {
          opacity: active ? 1 : 0.8,
          fontWeight: active && 'bold'
        }
      }, /*#__PURE__*/React.createElement("td", {
        style: {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          marginRight: '5px'
        }
      }, /*#__PURE__*/React.createElement("svg", {
        width: "16",
        height: "16"
      }, /*#__PURE__*/React.createElement("circle", {
        cx: "8",
        cy: "8",
        r: "7",
        style: _objectSpread2({}, getStyle(sortedDatum), {
          stroke: dark ? 'black' : 'white',
          strokeWidth: active ? 2 : 1
        })
      }))), grouping === groupingSeries ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("td", null, primaryAxis.format(sortedDatum.primary), ": \xA0"), /*#__PURE__*/React.createElement("td", {
        style: {
          textAlign: 'right'
        }
      }, resolvedSecondaryFormat(sortedDatum.secondary), sortedDatum.r ? " (".concat(resolvedFormatTertiary(sortedDatum.r), ")") : null)) : grouping === groupingSecondary ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("td", null, sortedDatum.seriesLabel, ": \xA0"), /*#__PURE__*/React.createElement("td", {
        style: {
          textAlign: 'right'
        }
      }, primaryAxis.format(sortedDatum.primary), sortedDatum.r ? " (".concat(resolvedFormatTertiary(sortedDatum.r), ")") : null)) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("td", null, sortedDatum.seriesLabel, ": \xA0"), /*#__PURE__*/React.createElement("td", {
        style: {
          textAlign: 'right'
        }
      }, resolvedSecondaryFormat(sortedDatum.secondary), sortedDatum.r ? " (".concat(resolvedFormatTertiary(sortedDatum.r), ")") : null)));
    }), hasNext ? /*#__PURE__*/React.createElement("tr", {
      style: {
        opacity: 0.8
      }
    }, /*#__PURE__*/React.createElement("td", null), /*#__PURE__*/React.createElement("td", null, "..."), /*#__PURE__*/React.createElement("td", null)) : null, secondaryAxis && secondaryAxis.stacked && datum.group.length > 1 ? /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("td", {
      style: {
        paddingTop: '5px'
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        width: '12px',
        height: '12px',
        backgroundColor: dark ? 'rgba(0, 26, 39, 0.3)' : 'rgba(255,255,255,.2)',
        borderRadius: '50px'
      }
    })), /*#__PURE__*/React.createElement("td", {
      style: {
        paddingTop: '5px'
      }
    }, "Total: \xA0"), /*#__PURE__*/React.createElement("td", {
      style: {
        paddingTop: '5px'
      }
    }, secondaryAxis.format(_toConsumableArray(datum.group).reverse()[0].totalValue))) : null)));
  }

  var useTooltip = (function (_ref) {
    var focused = _ref.focused,
        tooltip = _ref.tooltip,
        pointer = _ref.pointer,
        gridWidth = _ref.gridWidth,
        gridHeight = _ref.gridHeight;
    return React.useMemo(function () {
      if (!tooltip) {
        return null;
      } // Default tooltip props
      // eslint-disable-next-line react-hooks/exhaustive-deps


      tooltip = _objectSpread2({
        align: alignAuto,
        alignPriority: [alignRight, alignTopRight, alignBottomRight, alignLeft, alignTopLeft, alignBottomLeft, alignTop, alignBottom],
        padding: 5,
        tooltipArrowPadding: 7,
        anchor: 'closest',
        render: TooltipRenderer,
        onChange: function onChange() {}
      }, tooltip);
      var anchor = {};
      var show = true; // If there is a focused datum, default the focus to its x and y

      if (focused) {
        anchor = focused.anchor;
      } else {
        show = false;
      }

      if (tooltip.anchor === 'pointer') {
        // Support pointer-bound focus
        anchor = pointer;
      } else if (tooltip.anchor === 'closest') ; else if (focused) {
        // Support manual definition of focus point using relative multiFocus strategy
        var multiFocus = Array.isArray(tooltip.anchor) ? _toConsumableArray(tooltip.anchor) : [tooltip.anchor];
        anchor = Utils.getMultiAnchor({
          anchor: multiFocus,
          points: focused.group,
          gridWidth: gridWidth,
          gridHeight: gridHeight
        });
      }

      anchor = anchor ? _objectSpread2({
        horizontalPadding: anchor.horizontalPadding || 0,
        verticalPadding: anchor.verticalPadding || 0
      }, anchor) : anchor;
      return _objectSpread2({}, tooltip, {
        anchor: anchor,
        show: show
      });
    }, [focused, gridHeight, gridWidth, pointer, tooltip]);
  });

  var defaultCursorProps = {
    render: function render(_ref) {
      var formattedValue = _ref.formattedValue;
      return /*#__PURE__*/React.createElement("span", null, formattedValue);
    },
    snap: true,
    showLine: true,
    showLabel: true,
    axisID: undefined,
    onChange: function onChange() {}
  };
  var useCursors = (function (_ref2) {
    var primaryCursor = _ref2.primaryCursor,
        secondaryCursor = _ref2.secondaryCursor,
        primaryAxes = _ref2.primaryAxes,
        secondaryAxes = _ref2.secondaryAxes,
        focused = _ref2.focused,
        pointer = _ref2.pointer,
        gridWidth = _ref2.gridWidth,
        gridHeight = _ref2.gridHeight,
        stackData = _ref2.stackData;
    return [primaryCursor, secondaryCursor].map(function (cursor, i) {
      var cursorValue = cursor && cursor.value;
      return React.useMemo(function () {
        if (!cursor) {
          return;
        }

        var primary = i === 0; // eslint-disable-next-line react-hooks/exhaustive-deps

        cursor = _objectSpread2({}, defaultCursorProps, {}, cursor, {
          primary: primary
        });
        var value;
        var show = false; // Determine the axis to use

        var axis = Utils.getAxisByAxisID(primary ? primaryAxes : secondaryAxes, cursor.axisID || focused ? focused.series[primary ? 'primaryAxisID' : 'secondaryAxisID'] : undefined);
        var siblingAxis = primary ? secondaryAxes[0] : primaryAxes[0]; // Resolve the invert function

        var invert = axis.scale.invert || function (d) {
          return d;
        }; // If the pointer is active, try to show


        if (pointer.active) {
          // Default to cursor x and y
          var x = pointer.x;
          var y = pointer.y; // If the cursor isn't in the grid, don't display

          if (x < -1 || x > gridWidth + 1 || y < -1 || y > gridHeight + 1) {
            show = false;
          } else {
            show = true;
          } // Implement snapping


          if (axis.type === 'ordinal' || cursor.snap) {
            if (!focused) {
              show = false;
            } else {
              if (axis.vertical) {
                value = focused.yValue;
              } else {
                value = focused.xValue;
              }
            }
          } else if (axis.vertical) {
            value = invert(y);
          } else {
            value = invert(x);
          }
        } else {
          show = false;
        }

        var resolvedShow = show;
        var resolvedValue = value;

        if (typeof cursor.value !== 'undefined' && cursor.value !== null) {
          resolvedValue = cursor.value;

          if (typeof cursor.show !== 'undefined') {
            resolvedShow = cursor.show;
          } else {
            resolvedShow = true;
          }

          if (typeof axis.scale(resolvedValue) === 'undefined') {
            resolvedShow = false;
          }
        }

        return _objectSpread2({}, cursor, {
          axis: axis,
          siblingAxis: siblingAxis,
          show: show,
          value: value,
          resolvedShow: resolvedShow,
          resolvedValue: resolvedValue
        });
      }, [stackData, pointer, cursorValue]);
    });
  });

  var defaultProps = {
    getDatums: function getDatums(d) {
      return Array.isArray(d) ? d : d.datums || d.data;
    },
    getLabel: function getLabel(d, i) {
      return d.label || "Series ".concat(i + 1);
    },
    getSeriesID: function getSeriesID(d, i) {
      return i;
    },
    getPrimary: function getPrimary(d) {
      return Array.isArray(d) ? d[0] : d.primary || d.x;
    },
    getSecondary: function getSecondary(d) {
      return Array.isArray(d) ? d[1] : d.secondary || d.y;
    },
    getR: function getR(d) {
      return Array.isArray(d) ? d[2] : d.radius || d.r;
    },
    getPrimaryAxisID: function getPrimaryAxisID(s) {
      return s.primaryAxisID;
    },
    getSecondaryAxisID: function getSecondaryAxisID(s) {
      return s.secondaryAxisID;
    },
    getSeriesStyle: function getSeriesStyle(series) {
      return {
        color: series.originalSeries.color
      };
    },
    getDatumStyle: function getDatumStyle() {
      return {};
    },
    getSeriesOrder: function getSeriesOrder(d) {
      return d;
    },
    onHover: function onHover() {},
    grouping: groupingPrimary,
    focus: focusAuto,
    showVoronoi: false
  };
  function Chart(_ref) {
    var data = _ref.data,
        grouping = _ref.grouping,
        focus = _ref.focus,
        showVoronoi = _ref.showVoronoi,
        dark = _ref.dark,
        series = _ref.series,
        axes = _ref.axes,
        primaryCursor = _ref.primaryCursor,
        secondaryCursor = _ref.secondaryCursor,
        tooltip = _ref.tooltip,
        brush = _ref.brush,
        renderSVG = _ref.renderSVG,
        getDatums = _ref.getDatums,
        getLabel = _ref.getLabel,
        getSeriesID = _ref.getSeriesID,
        getPrimary = _ref.getPrimary,
        getSecondary = _ref.getSecondary,
        getR = _ref.getR,
        getPrimaryAxisID = _ref.getPrimaryAxisID,
        getSecondaryAxisID = _ref.getSecondaryAxisID,
        getSeriesStyle = _ref.getSeriesStyle,
        getDatumStyle = _ref.getDatumStyle,
        onClick = _ref.onClick,
        onFocus = _ref.onFocus,
        onHover = _ref.onHover,
        getSeriesOrder = _ref.getSeriesOrder,
        rest = _objectWithoutProperties(_ref, ["data", "grouping", "focus", "showVoronoi", "dark", "series", "axes", "primaryCursor", "secondaryCursor", "tooltip", "brush", "renderSVG", "getDatums", "getLabel", "getSeriesID", "getPrimary", "getSecondary", "getR", "getPrimaryAxisID", "getSecondaryAxisID", "getSeriesStyle", "getDatumStyle", "onClick", "onFocus", "onHover", "getSeriesOrder"]);

    var _React$useState = React.useState({
      focused: null,
      element: null,
      axisDimensions: {},
      padding: {},
      offset: {},
      pointer: {}
    }),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        _React$useState2$ = _React$useState2[0],
        focused = _React$useState2$.focused,
        element = _React$useState2$.element,
        axisDimensions = _React$useState2$.axisDimensions,
        offsetState = _React$useState2$.offset,
        padding = _React$useState2$.padding,
        pointer = _React$useState2$.pointer,
        setChartState = _React$useState2[1];

    var onClickRef = useLatestRef(onClick);
    var onFocusRef = useLatestRef(onFocus);
    var onHoverRef = useLatestRef(onHover);
    var responsiveElRef = React.useRef();

    var _useHyperResponsive = useRect(responsiveElRef),
        width = _useHyperResponsive.width,
        height = _useHyperResponsive.height;

    getSeriesID = React.useCallback(Utils.normalizeGetter(getSeriesID), [getSeriesID]);
    getLabel = React.useCallback(Utils.normalizeGetter(getLabel), [getLabel]);
    getPrimaryAxisID = React.useCallback(Utils.normalizeGetter(getPrimaryAxisID), [getPrimaryAxisID]);
    getSecondaryAxisID = React.useCallback(Utils.normalizeGetter(getSecondaryAxisID), [getSecondaryAxisID]);
    getDatums = React.useCallback(Utils.normalizeGetter(getDatums), [getDatums]);
    getPrimary = React.useCallback(Utils.normalizeGetter(getPrimary), [getPrimary]);
    getSecondary = React.useCallback(Utils.normalizeGetter(getSecondary), [getSecondary]);
    getR = React.useCallback(Utils.normalizeGetter(getR), [getR]);
    var materializedData = useMaterializeData({
      data: data,
      getSeriesID: getSeriesID,
      getLabel: getLabel,
      getPrimaryAxisID: getPrimaryAxisID,
      getSecondaryAxisID: getSecondaryAxisID,
      getDatums: getDatums,
      getPrimary: getPrimary,
      getSecondary: getSecondary,
      getR: getR
    });
    var seriesOptions = useSeriesOptions({
      materializedData: materializedData,
      series: series
    });
    materializedData = useSeriesTypes({
      materializedData: materializedData,
      seriesOptions: seriesOptions
    });

    var _useDimensions = useDimensions({
      width: width,
      height: height,
      axisDimensions: axisDimensions,
      padding: padding,
      offset: offsetState
    }),
        offset = _useDimensions.offset,
        gridX = _useDimensions.gridX,
        gridY = _useDimensions.gridY,
        gridWidth = _useDimensions.gridWidth,
        gridHeight = _useDimensions.gridHeight;

    var _useAxes = useAxes({
      axes: axes,
      materializedData: materializedData,
      gridHeight: gridHeight,
      gridWidth: gridWidth,
      axisDimensions: axisDimensions
    }),
        primaryAxes = _useAxes.primaryAxes,
        secondaryAxes = _useAxes.secondaryAxes,
        xKey = _useAxes.xKey,
        yKey = _useAxes.yKey,
        xAxes = _useAxes.xAxes,
        yAxes = _useAxes.yAxes;

    var stackData = useStackData({
      materializedData: materializedData,
      primaryAxes: primaryAxes,
      secondaryAxes: secondaryAxes,
      yAxes: yAxes,
      yKey: yKey,
      xAxes: xAxes,
      xKey: xKey,
      grouping: grouping
    });
    pointer = React.useMemo(function () {
      return _objectSpread2({}, pointer, {
        axisValues: [].concat(_toConsumableArray(primaryAxes), _toConsumableArray(secondaryAxes)).map(function (axis) {
          return {
            axis: axis,
            value: axis.scale.invert ? axis.scale.invert(pointer[axis.vertical ? 'y' : 'x']) : null
          };
        })
      });
    }, [pointer, primaryAxes, secondaryAxes]);
    focused = React.useMemo(function () {
      // Get the closest focus datum out of the datum group
      if (focused || element) {
        var resolvedFocus = focus;

        if (focus === focusAuto) {
          if (element) {
            resolvedFocus = focusElement;
          } else {
            resolvedFocus = focusClosest;
          }
        }

        if (resolvedFocus === focusElement && element) {
          return element;
        } else if (resolvedFocus === focusClosest) {
          return Utils.getClosestPoint(pointer, focused.group);
        }
      }

      return null;
    }, [element, focus, focused, pointer]); // keep the previous focused value around for animations

    var latestFocused = useLatest(focused, focused); // Calculate Tooltip

    tooltip = useTooltip({
      focused: focused,
      tooltip: tooltip,
      pointer: pointer,
      gridWidth: gridWidth,
      gridHeight: gridHeight
    }) // Cursors
    ;

    var _useCursors = useCursors({
      primaryCursor: primaryCursor,
      secondaryCursor: secondaryCursor,
      primaryAxes: primaryAxes,
      secondaryAxes: secondaryAxes,
      focused: focused,
      pointer: pointer,
      gridWidth: gridWidth,
      gridHeight: gridHeight,
      stackData: stackData
    });

    var _useCursors2 = _slicedToArray(_useCursors, 2);

    primaryCursor = _useCursors2[0];
    secondaryCursor = _useCursors2[1];
    React.useEffect(function () {
      if (onFocusRef.current) {
        onFocusRef.current(focused);
      }
    }, [onFocusRef, focused]);
    React.useEffect(function () {
      if (onHoverRef.current) {
        onHoverRef.current(pointer);
      }
    }, [onHoverRef, pointer]);
    var previousDragging = usePrevious(pointer.dragging);
    React.useEffect(function () {
      if (brush && previousDragging && !pointer.dragging) {
        if (Math.abs(pointer.sourceX - pointer.x) < 20) {
          return;
        }

        brush.onSelect({
          pointer: pointer.released,
          start: primaryAxes[0].scale.invert(pointer.sourceX),
          end: primaryAxes[0].scale.invert(pointer.x)
        });
      }
    }, [brush, pointer, pointer.released, pointer.sourceX, pointer.x, previousDragging, primaryAxes]); // Decorate the chartState with computed values (or ones we just
    // want to pass down through context)

    var chartState = React.useMemo(function () {
      return {
        focused: focused,
        latestFocused: latestFocused,
        pointer: pointer,
        tooltip: tooltip,
        axisDimensions: axisDimensions,
        offset: offset,
        padding: padding,
        width: width,
        height: height,
        brush: brush,
        grouping: grouping,
        showVoronoi: showVoronoi,
        materializedData: materializedData,
        stackData: stackData,
        primaryAxes: primaryAxes,
        secondaryAxes: secondaryAxes,
        primaryCursor: primaryCursor,
        secondaryCursor: secondaryCursor,
        gridX: gridX,
        gridY: gridY,
        gridWidth: gridWidth,
        gridHeight: gridHeight,
        dark: dark,
        renderSVG: renderSVG,
        xKey: xKey,
        yKey: yKey,
        xAxes: xAxes,
        yAxes: yAxes,
        onClickRef: onClickRef,
        getSeriesStyle: getSeriesStyle,
        getDatumStyle: getDatumStyle,
        seriesOptions: seriesOptions,
        getSeriesOrder: getSeriesOrder
      };
    }, [axisDimensions, brush, dark, focused, getDatumStyle, getSeriesOrder, getSeriesStyle, gridHeight, gridWidth, gridX, gridY, grouping, height, latestFocused, materializedData, offset, onClickRef, padding, pointer, primaryAxes, primaryCursor, renderSVG, secondaryAxes, secondaryCursor, seriesOptions, showVoronoi, stackData, tooltip, width, xAxes, xKey, yAxes, yKey]);
    var chartStateContextValue = React.useMemo(function () {
      return [chartState, setChartState];
    }, [chartState, setChartState]);
    return /*#__PURE__*/React.createElement(ChartContext.Provider, {
      value: chartStateContextValue
    }, /*#__PURE__*/React.createElement(ChartInner, _extends({
      ref: responsiveElRef
    }, rest, {
      onClick: function onClick(e) {
        if (onClickRef.current) {
          onClickRef.current(focused);
        }
      }
    })));
  }
  Chart.defaultProps = defaultProps;

  exports.Chart = Chart;
  exports.alignAuto = alignAuto;
  exports.alignBottom = alignBottom;
  exports.alignBottomLeft = alignBottomLeft;
  exports.alignBottomRight = alignBottomRight;
  exports.alignLeft = alignLeft;
  exports.alignRight = alignRight;
  exports.alignTop = alignTop;
  exports.alignTopLeft = alignTopLeft;
  exports.alignTopRight = alignTopRight;
  exports.anchorBottom = anchorBottom;
  exports.anchorCenter = anchorCenter;
  exports.anchorClosest = anchorClosest;
  exports.anchorGridBottom = anchorGridBottom;
  exports.anchorGridLeft = anchorGridLeft;
  exports.anchorGridRight = anchorGridRight;
  exports.anchorGridTop = anchorGridTop;
  exports.anchorLeft = anchorLeft;
  exports.anchorPointer = anchorPointer;
  exports.anchorRight = anchorRight;
  exports.anchorTop = anchorTop;
  exports.axisTypeLinear = axisTypeLinear;
  exports.axisTypeLog = axisTypeLog;
  exports.axisTypeOrdinal = axisTypeOrdinal;
  exports.axisTypeTime = axisTypeTime;
  exports.axisTypeUtc = axisTypeUtc;
  exports.curveBasis = Ki;
  exports.curveBasisClosed = nr;
  exports.curveBasisOpen = ir;
  exports.curveBundle = or;
  exports.curveCardinal = ar;
  exports.curveCardinalClosed = cr;
  exports.curveCardinalOpen = fr;
  exports.curveCatmullRom = gr;
  exports.curveCatmullRomClosed = xr;
  exports.curveCatmullRomOpen = vr;
  exports.curveLinear = Oi;
  exports.curveLinearClosed = Mr;
  exports.curveMonotoneX = Sr;
  exports.curveMonotoneY = Dr;
  exports.curveNatural = Rr;
  exports.curveStep = Pr;
  exports.curveStepAfter = Yr;
  exports.curveStepBefore = Fr;
  exports.focusAuto = focusAuto;
  exports.focusClosest = focusClosest;
  exports.focusElement = focusElement;
  exports.groupingPrimary = groupingPrimary;
  exports.groupingSecondary = groupingSecondary;
  exports.groupingSeries = groupingSeries;
  exports.groupingSingle = groupingSingle;
  exports.positionBottom = positionBottom;
  exports.positionLeft = positionLeft;
  exports.positionRight = positionRight;
  exports.positionTop = positionTop;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-charts.development.js.map
